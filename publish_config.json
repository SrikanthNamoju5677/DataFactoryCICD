{"publishBranch":"adf_publish","enableGitComment":true}


rXbPCqI8vwz72xNt8RDMgajEXhtv69puCmtfEVATJ0iYLRyrMgNOJDS39M5AJeD7
obgXW+ruJW1gcn2WGG9pDsRX74TYdOndBZ5sgAR0JHCOBawi88ZF9PkQmaDGOnK/
dvmj0iaKOPgZaIe5HGF6/QnqSffXeeOcBmTj3ge/8180gfO6jXtT7A94Lxo/7FFO
3FC8keKBbLHQlBP54ouhQCRdYMa4/uXycLZa2dfhaNO5KJGDzUOwC/8QenodcjyC
3JiFdrG8W9F11RetiT5mI0JrJd8Au2ysREgn+ejrgTUYHi5u25ezGsTD2GjElts5
tz3S085hrqHMttpayoq4vs3dmsY+9x7I+/YZlNsoYl5Of0rc0/Sm/quslqw3hazK
xAzsTUtHhFN8e5srijV6iVPP3sGJYOSXKzBSMsLeL9xCUc5Gv6FcAacrSQ6cms5u
SLzoSDfEcG6Xktn0zANm3WxH5gpjqUhaR9DtbDFqnUQXfNZcAQKCAQEA15BbhksG
yUgpwqAAMNHE+05/Up1/3BkI0MugrCdPi5bn/0iI0pHsCTDwJu3j/bmQrKELFsSQ
2ROi7F8ktFZQSos64XcScGOyEo3nE64V+72XJVYeb9iEq3hQ2JKvQtDYP3nDcrDX
QfxQHNF/tGKsJ7USiXsjHzac0mg4ZbyKJoFr1wRCLmWORNSY3Wg7aGZR2gZ/wzvH
KyUnv23UuLApmF80raoPzzJdkkRFrtGhHF/JNVd5wuIrT5WxQfScaDL16os+g32U
faIftMwDESSPWfLOJG++VLGWhPVhijrTazib7LS+oK1m2JzFlFCg+7kI+X9yw1va
oXXRcZFJZJMDgQKCAQEAxI4axGspunlCmz9JCOUDum+LR2Ionlx6tjdT54ZNbY7i
D4XRNlq1FfxkqjMI8WCRhAFjZ4zIEKItBIwvxosfz5Z0aNMXYX33QfXUxt3nMhcF
Gpd0cX5VC7g0tvXMUS2s1ZA6t3KkXcSVZ0Ha5RDEi9QwiwUwDa5+RTWTTaepRMdI
rR1UloGxsXGxkrkNaBXIE6hA/GjPOHMMiJ0lZT37d45uKhUsuYA/vY9FVllzHR+W
BiNwF08CgQJx3WSXUM3ZwhZH0laNS1pj5JS5h8T60vyWuw3ZTIj1dI0OPAUczodz
Gs2vj8dPNKJ3G9j3ahY4iix53fCSlMVt/RtCKG8ZEwKCAQBsYCpzsQK/baV5MSIH
aV9kjYmbyo1+5aM1/jpQcw8d+ge3pAsN+sk1scH7gHywknv3HpxJnRfJ24J83jTA





{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "clusterName": {
      "type": "string",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "The location of the Managed Cluster resource"
      }
    },
    "virtualNetworkRGName": {
      "type": "string",
      "metadata": {
        "description": "Existing VNET RG name for Kubernetes nodes"
      }
    },
    "virtualNetworkName": {
      "type": "string",
      "metadata": {
        "description": "Existing VNET name for Kubernetes nodes"
      }
    },
    "subnetName": {
      "type": "string",
      "metadata": {
        "description": "Existing subnet name for Kubernetes nodes"
      }
    },
    "serviceCidr": {
      "type": "string",
      "metadata": {
        "description": "CIDR block for all Kubernetes services"
      }
    },
    "dockerBridgeCidr": {
      "type": "string",
      "metadata": {
        "description": "CIDR block for all containers in kubernetes"
      }
    },
    "dnsServiceIP": {
      "type": "string",
      "metadata": {
        "description": "DNS service IP in kuberneties cluster"
      }
    },
    "osDiskSizeGB": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      },
      "minValue": 0,
      "maxValue": 1023
    },
    "dataDiskSizeGB": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      },
      "minValue": 0,
      "maxValue": 1023
    },
    "agentCount": {
      "type": "int",
      "metadata": {
        "description": "The number of worker nodes for the cluster"
      },
      "minValue": 1,
      "maxValue": 30
    },
    "workerNodeVMSize": {
      "type": "string",
      "metadata": {
        "description": "The size of the Virtual Machine"
      }
    },
    "linuxAdminUsername": {
      "type": "string",
      "metadata": {
        "description": "User name for the Linux Virtual Machines"
      }
    },
    "sshRSAPublicKey": {
      "type": "string",
      "metadata": {
        "description": "Configure all Linux machines with the SSH RSA public key string. Your key should include three parts, for example 'ssh-rsa AAAAB...snip...UcyupgH azureuser@linuxvm'"
      }
    },
    "windowsAdminUsername": {
      "type": "string",
      "metadata": {
        "description": "User name for the Windows Virtual Machines"
      }
    },
    "windowsAdminPassword": {
      "type": "string",
      "metadata": {
        "description": "Configure all Windows machines with this secure password for admin username"
      }
    },
    "servicePrincipalClientId": {
      "metadata": {
        "description": "Client ID (used by cloudprovider)"
      },
      "type": "string"
    },
    "servicePrincipalClientSecret": {
      "metadata": {
        "description": "The Service Principal Client Secret"
      },
      "type": "string"
    },
    "osType": {
      "type": "string",
      "allowedValues": [
        "Linux",
        "Windows"
      ],
      "metadata": {
        "description": "The type of operating system"
      }
    },
    "kubernetesVersion": {
      "type": "string",
      "metadata": {
        "description": "The version of Kubernetes"
      }
    },
    "enableHttpApplicationRouting": {
      "type": "bool",
      "metadata": {
        "description": "Boolean flag to turn on and off of http application routing"
      }
    },
    "networkPlugin": {
      "allowedValues": [
        "azure",
        "kubenet"
      ],
      "type": "string",
      "metadata": {
        "description": "Network plugin used for building Kubernetes network"
      }
    },
    "podCidr": {
      "type": "string",
      "metadata": {
        "description": "CIDR block for all pods in kubernetes (kubenet only)"
      }
    },
    "nodeRGName": {
      "type": "string",
      "metadata": {
        "description": "Name of the Resource Group for backend node"
      }
    },
    "enablePodSecurityPolicy": {
      "type": "bool",
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPolicy": {
      "type": "string",
      "allowedValues": [
        "azure",
        "calico"
      ],
      "metadata": {
        "description": "Pod security"
      }
    },
    "applicationGatewayName": {
      "type": "string",
      "metadata": {
        "description": "Name of the application gateway"
      }
    },
    "enableIngressApplicationGateway": {
      "type": "bool",
      "metadata": {
        "description": "Boolean flag to turn on and off Ingress ApplicationGateway"
      }
    },
    "agentPoolName": {
      "type": "string",
      "metadata": {
        "description": "Name of the agent node pool"
      }
    },
    "maxPods": {
      "type": "int",
      "defaultValue": 30
    }
  },
  "variables": {
    "subnetRef": "[resourceId(parameters('virtualNetworkRGName'), 'Microsoft.Network/virtualNetworks/subnets', parameters('virtualNetworkName'), parameters('subnetName'))]",
    "maxPods": "[parameters('maxPods')]",
    "clusterProperties": {
      "kubernetesVersion": "[parameters('kubernetesVersion')]",
      "dnsPrefix": "[concat(parameters('clusterName'),'-dns')]",
      "enableRBAC": true,
      "enablePodSecurityPolicy": "[parameters('enablePodSecurityPolicy')]",
      "nodeResourceGroup": "[parameters('nodeRGName')]",
      "addonProfiles": {
        "httpApplicationRouting": {
          "enabled": "[parameters('enableHttpApplicationRouting')]"
        },
        "ingressApplicationGateway": {
          "enabled": "[parameters('enableIngressApplicationGateway')]",
          "config": {
              "applicationGatewayId": "[resourceId('Microsoft.Network/applicationGateways',parameters('applicationGatewayName'))]"
          }
        }
      },
      "agentPoolProfiles": [
        {
          "name": "[parameters('agentPoolName')]",
          "type": "VirtualMachineScaleSets",
          "mode": "System",
          "osDiskSizeGB": "[parameters('osDiskSizeGB')]",
          "dataDiskSizeGB": "[parameters('dataDiskSizeGB')]",
          "count": "[parameters('agentCount')]",
          "vmSize": "[parameters('workerNodeVMSize')]",
          "osType": "[parameters('osType')]",
          "storageProfile": "ManagedDisks",
          "enableAutoScaling": false,
          "vnetSubnetID": "[variables('subnetRef')]",
          "maxPods": "[variables('maxPods')]"
        }
      ],
      "networkProfile": {
        "networkPlugin": "[parameters('networkPlugin')]",
        "serviceCidr": "[parameters('serviceCidr')]",
        "dockerBridgeCidr": "[parameters('dockerBridgeCidr')]",
        "dnsServiceIP": "[parameters('dnsServiceIP')]",
        "networkPolicy": "[parameters('networkPolicy')]",
        "podCidr": "[parameters('podCidr')]",
        "outboundType": "userDefinedRouting",
        "loadBalancerSku": "standard"
      },
      "apiServerAccessProfile": {
        "enablePrivateCluster": true,
        "privateDNSZone": "none"
      },
      "linuxProfile": {
        "adminUsername": "[parameters('linuxAdminUsername')]",
        "ssh": {
          "publicKeys": [
            {
              "keyData": "[parameters('sshRSAPublicKey')]"
            }
          ]
        }
      },
      "servicePrincipalProfile": {
        "clientId": "[parameters('servicePrincipalClientId')]",
        "Secret": "[parameters('servicePrincipalClientSecret')]"
      },
      "dependsOn": [
        "[concat('Microsoft.Resources/deployments/', 'SolutionDeployment')]"
      ]

  },
  "windowsprofileRef": {
      "windowsProfile": {
        "adminUsername": "[parameters('windowsAdminUsername')]",
        "adminPassword": "[parameters('windowsAdminPassword')]"
      }
    }
  },
  "resources": [
    {
      "apiVersion": "2021-10-01",
      "type": "Microsoft.ContainerService/managedClusters",
      "location": "[parameters('location')]",
      "name": "[parameters('clusterName')]",
      "properties": "[if(equals( parameters('networkPlugin'), 'azure'), union(variables('clusterProperties'), variables('windowsprofileRef')), variables('clusterProperties'))]"
    }
  ],
  "outputs": {
    "controlPlaneFQDN": {
      "type": "string",
      "value": "[reference(parameters('clusterName')).privateFQDN]"
    }
  }
}
------------------------------
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "clusterName": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "podCIDR": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "agentPoolName": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "location": {
      "value": "",
      "metadata": {
        "description": "The location of the Managed Cluster resource"
      }
    },
    "virtualNetworkRGName": {
      "value": "",
      "metadata": {
        "description": "Existing VNET RG name for Kubernetes nodes"
      }
    },
    "virtualNetworkName": {
      "value": "",
      "metadata": {
        "description": "Existing VNET name for Kubernetes nodes"
      }
    },
    "subnetName": {
      "value": "",
      "metadata": {
        "description": "Existing subnet name for Kubernetes nodes"
      }
    },
    "dnsPrefix": {
      "value": "",
      "metadata": {
        "description": "Optional DNS prefix to use with hosted Kubernetes API server FQDN"
      }
    },
    "serviceCidr": {
      "value": "",
      "metadata": {
        "description": "CIDR block for all Kubernetes services"
      }
    },
    "dockerBridgeCidr": {
      "value": "",
      "metadata": {
        "description": "CIDR block for all containers in kubernetes"
      }
    },
    "dnsServiceIP": {
      "value": "",
      "metadata": {
        "description": "DNS service IP in kuberneties cluster"
      }
    },
    "osDiskSizeGB": {
      "value": "",
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      }
    },
    "dataDiskSizeGB": {
      "value": "",
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      }
    },
    "agentCount": {
      "value": "",
      "metadata": {
        "description": "The number of worker nodes for the cluster"
      }
    },
    "workerNodeVMSize": {
      "value": "",
      "metadata": {
        "description": "The size of the Virtual Machine"
      }
    },
    "linuxAdminUsername": {
      "value": "",
      "metadata": {
        "description": "User name for the Linux Virtual Machines"
      }
    },
    "sshRSAPublicKey": {
      "value": "",
      "metadata": {
        "description": "Configure all Linux machines with the SSH RSA public key string. Your key should include three parts, for example 'ssh-rsa AAAAB...snip...UcyupgH azureuser@linuxvm'"
      }
    },
    "windowsAdminUsername": {
      "value": "",
      "metadata": {
        "description": "User name for the Windows Virtual Machines"
      }
    },
    "windowsAdminPassword": {
      "value": "",
      "metadata": {
        "description": "Configure all Windows machines with this secure password for admin username"
      }
    },
    "servicePrincipalClientId": {
      "value": "",
      "metadata": {
        "description": "Client ID (used by cloudprovider)"
      }
    },
    "servicePrincipalClientSecret": {
      "value": "",
      "metadata": {
        "description": "The Service Principal Client Secret"
      }
    },
    "osType": {
      "value": "",
      "metadata": {
        "description": "The type of operating system"
      }
    },
    "kubernetesVersion": {
      "value": "",
      "metadata": {
        "description": "The version of Kubernetes"
      }
    },
    "enableOmsAgent": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of OMS agent addon"
      }
    },
    "enableHttpApplicationRouting": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of http application routing"
      }
    },
    "networkPlugin": {
      "value": "",
      "metadata": {
        "description": "Network plugin used for building Kubernetes network"
      }
    },
    "enableRBAC": {
      "value": "",
      "metadata": {
        "description": "Flag to turn on/off RBAC"
      }
    },
    "EnableAutoScaling": {
      "value": "",
      "metadata": {
        "description": "Flag to turn on/off auto scaling"
      }
    },
    "nodeRGName": {
      "value": "",
      "metadata": {
        "description": "Name of the Resource Group for backend node"
      }
    },
    "enablePodSecurityPolicy": {
      "value": "",
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPolicy": {
      "value": "",
      "metadata": {
        "description": "Pod security"
      }
    },
    "applicationGatewayName": {
      "value": "",
      "metadata": {
        "description": "Name of the application gateway"
      }
    },
    "enableIngressApplicationGateway": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off Ingress ApplicationGateway"
      }
    },
    "logAnalyticsWorkspaceName": {
      "value": "",
      "metadata": {
        "description": "Name of the log analytics workspace which will be used for container analytics"
      }
    },
    "logAnalyticsResourceGroup": {
      "value": "",
      "metadata": {
        "description": "The Resource Group in which the log analytics workspace is deployed"
      }
    }
  }
}
-------------------------------
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
      "clusterName": {
          "type": "string",
          "metadata": {
              "description": "The name of your existing AKS cluster."
          }
      },
      "location": {
          "type": "string",
          "defaultValue": "",
          "metadata": {
              "description": "The location of your existing AKS cluster."
          }
      },
      "agentPoolName": {
          "type": "string",
          "metadata": {
              "description": "The name of the agent pool to create or update."
          }
      },
      "workerNodeVMSize": {
          "type": "string",
          "metadata": {
              "description": "The size of the Virtual Machine"
          }
      },
      "osType": {
          "type": "string",
          "allowedValues": [
              "Linux",
              "Windows"
          ],
          "metadata": {
              "description": "The type of operating system"
          }
      },
      "virtualNetworkRGName": {
          "type": "string",
          "metadata": {
              "description": "Existing VNET RG name for Kubernetes nodes"
          }
      },
      "virtualNetworkName": {
          "type": "string",
          "metadata": {
              "description": "Existing VNET name for Kubernetes nodes"
          }
      },
      "subnetName": {
          "type": "string",
          "metadata": {
              "description": "Existing subnet name for Kubernetes nodes"
          }
      },
      "agentCount": {
          "type": "int",
          "metadata": {
              "description": "The number of worker nodes for the nodepool"
          },
          "minValue": 1,
          "maxValue": 30
      },
      "maxPods": {
        "type": "int",
        "defaultValue": 30
      }
  },
  "variables": {
      "subnetRef": "[resourceId(parameters('virtualNetworkRGName'), 'Microsoft.Network/virtualNetworks/subnets', parameters('virtualNetworkName'), parameters('subnetName'))]",
      "agentPoolProfiles": {
          "maxCount": 30,
          "minCount": 2,
          "maxPods": "[parameters('maxPods')]",
          "osDiskSizeGB": 0,
          "dataDiskSizeGB": 0,
          "agentCount": "[parameters('agentCount')]",
          "agentVmSize": "[parameters('workerNodeVMSize')]",
          "osType": "[parameters('osType')]",
          "vnetSubnetId": "[variables('subnetRef')]"
      }
  },
  "resources": [
        {
          "apiVersion": "2020-01-01",
          "type": "Microsoft.ContainerService/managedClusters/agentPools",
          "name": "[concat(parameters('clusterName'),'/', parameters('agentPoolName'))]",
          "location": "[parameters('location')]",
          "properties": {
              "maxCount": "[variables('agentPoolProfiles').maxCount]",
              "minCount": "[variables('agentPoolProfiles').minCount]",
              "maxPods": "[variables('agentPoolProfiles').maxPods]",
              "osDiskSizeGB": "[variables('agentPoolProfiles').osDiskSizeGB]",
              "dataDiskSizeGB": "[variables('agentPoolProfiles').dataDiskSizeGB]",
              "count": "[variables('agentPoolProfiles').agentCount]",
              "vmSize": "[variables('agentPoolProfiles').agentVmSize]",
              "osType": "[variables('agentPoolProfiles').osType]",
              "storageProfile": "ManagedDisks",
              "type": "VirtualMachineScaleSets",
              "enableAutoScaling":true,
              "vnetSubnetID": "[variables('agentPoolProfiles').vnetSubnetId]",
              "nodeTaints":[
                  "[concat('Workload=', parameters('agentPoolName'),':NoSchedule')]"
              ]
          }
      }
  ]
}
-----------------------
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "clusterName": {
      "type": "string",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "clusterSKUTier": {
      "type": "string",
      "metadata": {
        "description": "The SKU tier of the Cluster"
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "The location of the Managed Cluster resource"
      }
    },
    "virtualNetworkRGName": {
      "type": "string",
      "metadata": {
        "description": "Existing VNET RG name for Kubernetes nodes"
      }
    },
    "virtualNetworkName": {
      "type": "string",
      "metadata": {
        "description": "Existing VNET name for Kubernetes nodes"
      }
    },
    "subnetName": {
      "type": "string",
      "metadata": {
        "description": "Existing subnet name for Kubernetes nodes"
      }
    },
    "serviceCidr": {
      "type": "string",
      "metadata": {
        "description": "CIDR block for all Kubernetes services"
      }
    },
    "dnsServiceIP": {
      "type": "string",
      "metadata": {
        "description": "DNS service IP in kuberneties cluster"
      }
    },
    "osDiskSizeGB": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      },
      "minValue": 0,
      "maxValue": 1023
    },
    "dataDiskSizeGB": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      },
      "minValue": 0,
      "maxValue": 1023
    },
    "agentCount": {
      "type": "int",
      "metadata": {
        "description": "The number of worker nodes for the cluster"
      },
      "minValue": 1,
      "maxValue": 30
    },
    "workerNodeVMSize": {
      "type": "string",
      "metadata": {
        "description": "The size of the Virtual Machine"
      }
    },
    "linuxAdminUsername": {
      "type": "string",
      "metadata": {
        "description": "User name for the Linux Virtual Machines"
      }
    },
    "sshRSAPublicKey": {
      "type": "string",
      "metadata": {
        "description": "Configure all Linux machines with the SSH RSA public key string. Your key should include three parts, for example 'ssh-rsa AAAAB...snip...UcyupgH azureuser@linuxvm'"
      }
    },
    "windowsAdminUsername": {
      "type": "string",
      "metadata": {
        "description": "User name for the Windows Virtual Machines"
      }
    },
    "windowsAdminPassword": {
      "type": "string",
      "metadata": {
        "description": "Configure all Windows machines with this secure password for admin username"
      }
    },
    "osType": {
      "type": "string",
      "allowedValues": [
        "Linux",
        "Windows"
      ],
      "metadata": {
        "description": "The type of operating system"
      }
    },
    "kubernetesVersion": {
      "type": "string",
      "metadata": {
        "description": "The version of Kubernetes"
      }
    },
    "enableKeyvaultSecretsProvider": {
      "type": "bool",
      "metadata": {
        "description": "Boolean flag to turn on and off of key vault secrets provider"
      }
    },
    "enableKeyvaultSecretsRotation": {
      "type": "string",
      "metadata": {
        "description": "String to turn on and off of key vault secrets provider rotation"
      }
    },
    "keyvaultSecretsRotationInterval": {
      "type": "string",
      "metadata": {
        "description": "Boolean flag to turn on and off of key vault secrets provider rotation interval"
      }
    },
    "enableHttpApplicationRouting": {
      "type": "bool",
      "metadata": {
        "description": "Boolean flag to turn on and off of http application routing"
      }
    },
    "networkPlugin": {
      "allowedValues": [
        "azure",
        "kubenet"
      ],
      "type": "string",
      "metadata": {
        "description": "Network plugin used for building Kubernetes network"
      }
    },
    "podCidr": {
      "type": "string",
      "metadata": {
        "description": "CIDR block for all pods in kubernetes (kubenet only)"
      }
    },
    "nodeRGName": {
      "type": "string",
      "metadata": {
        "description": "Name of the Resource Group for backend node"
      }
    },
    "enablePodSecurityPolicy": {
      "type": "bool",
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPolicy": {
      "type": "string",
      "allowedValues": [
        "azure",
        "calico"
      ],
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPluginMode": {
      "defaultValue": "",
      "type": "string",
      "metadata": {
        "description": "Network plugin mode for cni"
      }
    },
    "applicationGatewayName": {
      "type": "string",
      "metadata": {
        "description": "Name of the application gateway"
      }
    },
    "enableIngressApplicationGateway": {
      "type": "bool",
      "metadata": {
        "description": "Boolean flag to turn on and off Ingress ApplicationGateway"
      }
    },
    "agentPoolName": {
      "type": "string",
      "metadata": {
        "description": "Name of the agent node pool"
      }
    },
    "maxPods": {
      "type": "int",
      "defaultValue": 30
    },
    "aksManagedIdentity": {
      "type": "string",
      "metadata": {
        "description": "Name of the user assigned managed identity"
      }
    },
    "upgradeChannel": {
      "type": "string",
      "metadata": {
        "description": "AKS Cluster Automatic channel upgrade"
      }
    },
    "nodeOSUpgradeChannel": {
      "type": "string",
      "metadata": {
        "description": "AKS Node OS Automatic channel upgrade"
      }
    },
    "adminGroupObjectId": {
      "type": "string",
      "metadata": {
        "description": "The Id of the Azure AD Contributor group"
      }
    }
  },
  "variables": {
    "subnetRef": "[resourceId(parameters('virtualNetworkRGName'), 'Microsoft.Network/virtualNetworks/subnets', parameters('virtualNetworkName'), parameters('subnetName'))]",
    "maxPods": "[parameters('maxPods')]",
    "managedIdentityOperatorRoleDefId": "f1a07417-d97a-45cb-824c-7a7467783830",
    "vmContributorRoleDefId": "9980e02c-c2be-4d73-94e8-173b1dc7cf3c",
    "kubenetNetworkProfile": {
      "networkPlugin": "[parameters('networkPlugin')]",
      "serviceCidr": "[parameters('serviceCidr')]",
      "dnsServiceIP": "[parameters('dnsServiceIP')]",
      "networkPolicy": "[parameters('networkPolicy')]",
      "podCidr": "[parameters('podCidr')]",
      "outboundType": "userDefinedRouting",
      "loadBalancerSku": "standard"
    },
    "cniNetworkProfile": {
      "networkPlugin": "[parameters('networkPlugin')]",
      "serviceCidr": "[parameters('serviceCidr')]",
      "dnsServiceIP": "[parameters('dnsServiceIP')]",
      "networkPolicy": "[parameters('networkPolicy')]",
      "podCidr": "[ if(equals( parameters('networkPluginMode'), 'Overlay'),parameters('podCidr'), '' )]",
      "networkPluginMode": "[ if(equals( parameters('networkPluginMode'), 'Overlay'),'Overlay', '' )]",
      "outboundType": "userDefinedRouting",
      "loadBalancerSku": "standard"
    },
    "ingressAddOn": {
      "enabled": "[parameters('enableIngressApplicationGateway')]",
      "config": {
        "applicationGatewayId": "[resourceId('Microsoft.Network/applicationGateways',parameters('applicationGatewayName'))]"
      }
    },
    "clusterProperties": {
      "kubernetesVersion": "[parameters('kubernetesVersion')]",
      "dnsPrefix": "[concat(parameters('clusterName'),'-dns')]",
      "enableRBAC": true,
      "enablePodSecurityPolicy": "[parameters('enablePodSecurityPolicy')]",
      "nodeResourceGroup": "[parameters('nodeRGName')]",
      "aadProfile": {
        "adminGroupObjectIDs": [
          "[parameters('adminGroupObjectId')]"
        ],
        "enableAzureRBAC": true,
        "managed": true,
        "tenantID": "[subscription().tenantId]"
      },
      "addonProfiles": {
        "azureKeyvaultSecretsProvider": {
          "enabled": "[parameters('enableKeyvaultSecretsProvider')]",
          "config": {
            "enableSecretRotation": "[parameters('enableKeyvaultSecretsRotation')]",
            "rotationPollInterval": "[parameters('keyvaultSecretsRotationInterval')]"
          }
        },
        "azurepolicy": {
          "enabled": true
        },
        "httpApplicationRouting": {
          "enabled": "[parameters('enableHttpApplicationRouting')]"
        },
        "ingressApplicationGateway": "[if(and(equals( parameters('networkPlugin'), 'azure'), equals( parameters('networkPluginMode'), 'Overlay')), null(), variables('ingressAddOn'))]"
      },
      "agentPoolProfiles": [
        {
          "name": "[parameters('agentPoolName')]",
          "type": "VirtualMachineScaleSets",
          "mode": "System",
          "osDiskSizeGB": "[parameters('osDiskSizeGB')]",
          "dataDiskSizeGB": "[parameters('dataDiskSizeGB')]",
          "count": "[parameters('agentCount')]",
          "vmSize": "[parameters('workerNodeVMSize')]",
          "osType": "[parameters('osType')]",
          "storageProfile": "ManagedDisks",
          "enableAutoScaling": false,
          "vnetSubnetID": "[variables('subnetRef')]",
          "maxPods": "[variables('maxPods')]"
        }
      ],
      "networkProfile": "[if(equals( parameters('networkPlugin'), 'azure'), variables('cniNetworkProfile'), variables('kubenetNetworkProfile'))]",
      "apiServerAccessProfile": {
        "enablePrivateCluster": true,
        "enablePrivateClusterPublicFQDN": true,
        "privateDNSZone": "none"
      },
      "autoUpgradeProfile": {
        "nodeOSUpgradeChannel": "[parameters('nodeOSUpgradeChannel')]",
        "upgradeChannel": "[parameters('upgradeChannel')]"
      },
      "linuxProfile": {
        "adminUsername": "[parameters('linuxAdminUsername')]",
        "ssh": {
          "publicKeys": [
            {
              "keyData": "[parameters('sshRSAPublicKey')]"
            }
          ]
        }
      },
      "dependsOn": [
        "[concat('Microsoft.Resources/deployments/', 'SolutionDeployment')]"
      ]
    },
    "windowsprofileRef": {
      "windowsProfile": {
        "adminUsername": "[parameters('windowsAdminUsername')]",
        "adminPassword": "[parameters('windowsAdminPassword')]"
      }
    }
  },
  "resources": [
    {
      "apiVersion": "2023-04-01",
      "type": "Microsoft.ContainerService/managedClusters",
      "location": "[parameters('location')]",
      "name": "[parameters('clusterName')]",
      "sku": {
        "name": "Base",
        "tier": "[parameters('clusterSKUTier')]"
      },
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('aksManagedIdentity'))]": {}
        }
      },
      "properties": "[if(equals( parameters('networkPlugin'), 'azure'), union(variables('clusterProperties'), variables('windowsprofileRef')), variables('clusterProperties'))]"
    },
    {
      "type": "Microsoft.Resources/deployments",
      "name": "AKSNodeRGVMContributorRoleAssignmentDeployment",
      "apiVersion": "2021-04-01",
      "resourceGroup": "[parameters('nodeRGName')]",
      "dependsOn": [
        "[resourceId('Microsoft.ContainerService/managedClusters', parameters('clusterName'))]"
      ],
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "outer"
        },
        "mode": "Incremental",
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2021-04-01-preview",
              "name": "[guid(concat(resourceGroup().id), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('aksManagedIdentity')), parameters('aksManagedIdentity'), variables('vmContributorRoleDefId'))]",
              "properties": {
                "description": "VM Contributor rights role assignment for NodeRG",
                "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('aksManagedIdentity')), '2018-11-30', 'Full').properties.principalId]",
                "principalType": "ServicePrincipal",
                "scope": "[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', parameters('nodeRGName'))]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('vmContributorRoleDefId'))]"
              }
            }
          ]
        }
      }
    },
    {
      "type": "Microsoft.Resources/deployments",
      "name": "AKSNodeRGMIOperatorRoleAssignmentDeployment",
      "apiVersion": "2021-04-01",
      "resourceGroup": "[parameters('nodeRGName')]",
      "dependsOn": [
        "[resourceId('Microsoft.ContainerService/managedClusters', parameters('clusterName'))]"
      ],
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "outer"
        },
        "mode": "Incremental",
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2021-04-01-preview",
              "name": "[guid(concat(resourceGroup().id), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('aksManagedIdentity')), parameters('aksManagedIdentity'), variables('managedIdentityOperatorRoleDefId'))]",
              "properties": {
                "description": "Managed Identity Operator rights role assignment for NodeRG",
                "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('aksManagedIdentity')), '2018-11-30', 'Full').properties.principalId]",
                "principalType": "ServicePrincipal",
                "scope": "[concat('/subscriptions/', subscription().subscriptionId, '/resourceGroups/', parameters('nodeRGName'))]",
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', variables('managedIdentityOperatorRoleDefId'))]"
              }
            }
          ]
        }
      }
    }
  ],
  "outputs": {
    "controlPlaneFQDN": {
      "type": "string",
      "value": "[reference(parameters('clusterName')).privateFQDN]"
    }
  }
}
----------------------------------
{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "clusterName": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "clusterSKUTier": {
      "value": "",
      "metadata": {
        "description": "The SKU tier of the Cluster"
      }
    },
    "podCIDR": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "agentPoolName": {
      "value": "",
      "metadata": {
        "description": "The name of the Managed Cluster resource"
      }
    },
    "location": {
      "value": "",
      "metadata": {
        "description": "The location of the Managed Cluster resource"
      }
    },
    "virtualNetworkRGName": {
      "value": "",
      "metadata": {
        "description": "Existing VNET RG name for Kubernetes nodes"
      }
    },
    "virtualNetworkName": {
      "value": "",
      "metadata": {
        "description": "Existing VNET name for Kubernetes nodes"
      }
    },
    "subnetName": {
      "value": "",
      "metadata": {
        "description": "Existing subnet name for Kubernetes nodes"
      }
    },
    "dnsPrefix": {
      "value": "",
      "metadata": {
        "description": "Optional DNS prefix to use with hosted Kubernetes API server FQDN"
      }
    },
    "serviceCidr": {
      "value": "",
      "metadata": {
        "description": "CIDR block for all Kubernetes services"
      }
    },
    "dnsServiceIP": {
      "value": "",
      "metadata": {
        "description": "DNS service IP in kuberneties cluster"
      }
    },
    "osDiskSizeGB": {
      "value": "",
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      }
    },
    "dataDiskSizeGB": {
      "value": "",
      "metadata": {
        "description": "Disk size (in GB) to provision for each of the agent pool nodes. This value ranges from 0 to 1023. Specifying 0 will apply the default disk size for that agentVMSize"
      }
    },
    "agentCount": {
      "value": "",
      "metadata": {
        "description": "The number of worker nodes for the cluster"
      }
    },
    "workerNodeVMSize": {
      "value": "",
      "metadata": {
        "description": "The size of the Virtual Machine"
      }
    },
    "linuxAdminUsername": {
      "value": "",
      "metadata": {
        "description": "User name for the Linux Virtual Machines"
      }
    },
    "sshRSAPublicKey": {
      "value": "",
      "metadata": {
        "description": "Configure all Linux machines with the SSH RSA public key string. Your key should include three parts, for example 'ssh-rsa AAAAB...snip...UcyupgH azureuser@linuxvm'"
      }
    },
    "windowsAdminUsername": {
      "value": "",
      "metadata": {
        "description": "User name for the Windows Virtual Machines"
      }
    },
    "windowsAdminPassword": {
      "value": "",
      "metadata": {
        "description": "Configure all Windows machines with this secure password for admin username"
      }
    },
    "osType": {
      "value": "",
      "metadata": {
        "description": "The type of operating system"
      }
    },
    "kubernetesVersion": {
      "value": "",
      "metadata": {
        "description": "The version of Kubernetes"
      }
    },
    "enableOmsAgent": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of OMS agent addon"
      }
    },
    "enableKeyvaultSecretsProvider": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of key vault secrets provider"
      }
    },
    "enableKeyvaultSecretsRotation": {
      "value": "",
      "metadata": {
        "description": "String to turn on and off of key vault secrets provider rotation"
      }
    },
    "keyvaultSecretsRotationInterval": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of key vault secrets provider rotation interval"
      }
    },
    "enableHttpApplicationRouting": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off of http application routing"
      }
    },
    "networkPlugin": {
      "value": "",
      "metadata": {
        "description": "Network plugin used for building Kubernetes network"
      }
    },
    "enableRBAC": {
      "value": "",
      "metadata": {
        "description": "Flag to turn on/off RBAC"
      }
    },
    "EnableAutoScaling": {
      "value": "",
      "metadata": {
        "description": "Flag to turn on/off auto scaling"
      }
    },
    "nodeRGName": {
      "value": "",
      "metadata": {
        "description": "Name of the Resource Group for backend node"
      }
    },
    "enablePodSecurityPolicy": {
      "value": "",
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPolicy": {
      "value": "",
      "metadata": {
        "description": "Pod security"
      }
    },
    "networkPluginMode": {
      "value": "",
      "metadata": {
        "description": "Pod security"
      }
    },
    "applicationGatewayName": {
      "value": "",
      "metadata": {
        "description": "Name of the application gateway"
      }
    },
    "enableIngressApplicationGateway": {
      "value": "",
      "metadata": {
        "description": "Boolean flag to turn on and off Ingress ApplicationGateway"
      }
    },
    "logAnalyticsWorkspaceName": {
      "value": "",
      "metadata": {
        "description": "Name of the log analytics workspace which will be used for container analytics"
      }
    },
    "logAnalyticsResourceGroup": {
      "value": "",
      "metadata": {
        "description": "The Resource Group in which the log analytics workspace is deployed"
      }
    },
    "aksManagedIdentity": {
      "value": "",
      "metadata": {
        "description": "Name of the user assigned managed identity"
      }
    },
    "upgradeChannel": {
      "value": "",
      "metadata": {
        "description": "AKS Cluster Automatic channel upgrade"
      }
    },
    "nodeOSUpgradeChannel": {
      "value": "",
      "metadata": {
        "description": "AKS Node OS Automatic channel upgrade"
      }
    },
    "adminGroupObjectId": {
      "value": "",
      "metadata": {
        "description": "The Object Id of the contributor AAD group"
      }
    }
  }
}
------------------------
{
  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",

  "parameters": {
      "userAssignedManagedIdentityName": {
          "type": "string",
          "metadata": {
              "description": "The name of the user assigned managed identity"
          }
      },
      "location": {
          "type": "string",
          "defaultValue": "",
          "metadata": {
              "description": "The location of your"
          }
      }
  },
  "resources": [
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "name": "[parameters('userAssignedManagedIdentityName')]",
      "apiVersion": "2018-11-30",
      "location": "[parameters('location')]"
    }
  ],
  "outputs": {
      "identityName": {
          "type": "string",
          "value": "[parameters('userAssignedManagedIdentityName')]"
      }
  }
}
-----------------------------
parameters:
  - name: agentCount
    type: string
  - name: agentPoolName
    type: string
  - name: aksClusterName
    type: string
  - name: aksClusterSKUTier
    default: "Free"
    type: string    
  - name: aksKeyVaultName
    type: string
    default: 'Empty'
  - name: aksNetworkPlugin
    type: string
  - name: aksNetworkPluginMode
    type: string
    default: 'Empty'  
  - name: aksOsType
    type: string
  - name: aksNodePoolResourceGroupName
    type: string
  - name: aksResourceGroupName
    type: string
  - name: aksResourceGroupNamePrefix
    type: string
  - name: azureSubscription
    type: string
  - name: dnsServiceIP
    type: string
    default: '198.19.0.10'
  - name: kubernetesVersion
    type: string
  - name: linuxAdminUsername
    type: string
  - name: location
    type: string
  - name: networkPolicy
    type: string
  - name: podCidr
    type: string
    default: '198.18.0.0/16'
  - name: serviceCidr
    type: string
    default: '198.19.0.0/17'
  - name: subnetName
    type: string
  - name: virtualNetworkName
    type: string
  - name: virtualNetworkRGName
    type: string
  - name: virtualNetworkSubnetName
    type: string
  - name: workerNodeVMSize
    type: string
  - name: maxPods
    type: number
  - name: sshRsaPublicKey
    type: string
  - name: applicationGatewayName
    type: string
  - name: windowsAdminUsername
    type: string
  - name: windowsAdminPassword
    type: string    
  - name: aksManagedIdentityName
    type: string
  - name: aksKubeletManagedIdentityName
    type: string
    default: "Empty"   
  - name: acrRegistryName
    type: string
    default: "Empty"
  - name: keyvaultSecretsRotationInterval
    type: string
    default: "2m"
  - name: UpgradeChannel
    type: string
    default: "stable"     
  - name: NodeOSUpgradeChannel
    type: string
    default: "NodeImage"


steps:
- task: AzurePowerShell@5
  name: Identity
  displayName: 'Create UserAssigned Managed Identity & Fetch AAD Group'
  condition: succeeded()
  inputs:
    azureSubscription: '${{ parameters.azureSubscription }}'
    ScriptType: InlineScript
    Inline: |
      $AllModules = Get-Module -All
      $AzManagedServiceIdentity = $False
      $AzAccounts = $False
      $AzResources = $False
      foreach($Module in $AllModules.Name){
        if($Module.Name -eq "Az.ManagedServiceIdentity") { $AzManagedServiceIdentity = $True }
        if($Module.Name -eq "Az.Accounts" -and $Module.Version.ToString() -eq '2.13.2') { $AzAccounts = $True }
        if($Module.Name -eq "Az.Resources") { $AzResources = $True }        
      }
      if($AzAccounts){
        Write-Host "Installing update of Az.Accounts"
        Install-Module -Name 'Az.Accounts' -RequiredVersion '2.13.2' -Force
        Remove-Module -Name 'Az.Accounts'
        Import-Module -Name 'Az.Accounts' -Force          
      }
      if($AzManagedServiceIdentity){
        Install-Module -Name 'Az.ManagedServiceIdentity' -RequiredVersion '1.1.0' -Force
        Import-Module -Name 'Az.ManagedServiceIdentity' -Force          
      }
      if($AzResources){
        Install-Module -Name 'Az.Resources' -Force
        Import-Module -Name 'Az.Resources' -Force          
      }            
      $aksManagedIdentity = New-AzUserAssignedIdentity -Name ${{ parameters.aksManagedIdentityName }} -ResourceGroupName ${{ parameters.aksResourceGroupName }} -Location ${{ parameters.location }}
      Start-Sleep -Seconds 60
      try {
        New-AzRoleAssignment -ApplicationId $aksManagedIdentity.ClientId -RoleDefinitionName "Network Contributor" -Scope (Get-AzResourceGroup "${{ parameters.virtualNetworkRGName}}").ResourceId
      }
      catch {
        $ErrorMessage = $_.Exception.Message
        if( $ErrorMessage.Contains('Conflict')) {
          Write-Host "Role assignment already present for ${{ parameters.aksManagedIdentityName }} !!!"
        } else {
          Write-Error "Role assignment failed with error: $ErrorMessage"
        }
      }
      Write-Host "Formulate the contributor AAD group"
      try {
        $subscriptionName = (Get-AzContext).Subscription.Name
        $subscriptionNameArray = $subscriptionName.Split('-')

        $subscriptionNameArray[1] = $subscriptionNameArray[1] -replace '\d', ''
        if(  $subscriptionNameArray[1] -eq 'dta' ){
          $adminGroupName = ($subscriptionNameArray -join '-') + "-Contributor"
        } elseif ( $subscriptionNameArray[1] -eq 'prd' ){
          $adminGroupName = ($subscriptionNameArray -join '-') + "-Reader"
        }
        $adminGroupObjectId = (Get-AzADGroup -DisplayNameStartsWith $adminGroupName).Id
      }
      catch {
        $ErrorMessage = $_.Exception.Message
        Write-Error "$ErrorMessage"
      }
      Write-Host "The contributor AAD group: $adminGroupObjectId"
      Write-Host "##vso[task.setvariable variable=adminGroupObjectId;isOutput=true;issecret=false;]$adminGroupObjectId"

    FailOnStandardError: true
    azurePowerShellVersion: LatestVersion
    pwsh: true

- task: AzurePowerShell@5
  displayName: 'Create AKS Cluster - ${{ parameters.aksClusterName }}'
  condition: succeeded()
  inputs:
    azureSubscription: '${{ parameters.azureSubscription }}'
    ScriptPath: '$(System.DefaultWorkingDirectory)/powershell/Create-KubernetesService-mi.ps1'
    ScriptArguments:
      -ResourceGroupName '${{ parameters.aksResourceGroupName }}'
      -clusterName '${{ parameters.aksClusterName }}'
      -clusterSKUTier '${{ parameters.aksClusterSKUTier }}'
      -location '${{ parameters.location }}'
      -virtualNetworkRGName '${{ parameters.virtualNetworkRGName }}'
      -virtualNetworkName '${{ parameters.virtualNetworkName }}'
      -subnetName '${{ parameters.subnetName }}'
      -serviceCidr '${{ parameters.serviceCidr }}'
      -dnsServiceIP '${{ parameters.dnsServiceIP }}'
      -osDiskSizeGB 0
      -dataDiskSizeGB 0
      -agentCount '${{ parameters.agentCount }}'
      -workerNodeVMSize '${{ parameters.workerNodeVMSize }}'
      -linuxAdminUsername '${{ parameters.linuxAdminUsername }}'
      -sshRSAPublicKey '${{ parameters.sshRsaPublicKey }}'
      -windowsAdminUsername '${{ parameters.windowsAdminUsername }}'
      -windowsAdminPassword '${{ parameters.windowsAdminPassword }}'
      -osType '${{ parameters.aksOsType }}'
      -kubernetesVersion '${{ parameters.kubernetesVersion }}'
      -EnableKeyvaultSecretsProvider $true
      -EnableKeyvaultSecretsRotation "true"
      -KeyvaultSecretsRotationInterval '${{ parameters.keyvaultSecretsRotationInterval }}'      
      -enableHttpApplicationRouting $false
      -networkPlugin '${{ parameters.aksNetworkPlugin }}'
      -networkPluginMode '${{ parameters.aksNetworkPluginMode }}'      
      -DeploymentDebugLevel None
      -nodeRGName '${{ parameters.aksNodePoolResourceGroupName }}'
      -enablePodSecurityPolicy $false
      -networkPolicy '${{ parameters.networkPolicy }}'
      -PodCidr '${{ parameters.podCidr }}'
      -AgentPoolName '${{ parameters.agentPoolName }}'
      -MaxPods ${{ parameters.maxPods }}
      -ApplicationGatewayName ${{ parameters.applicationGatewayName}}
      -EnableIngressApplicationGateway $true
      -AKSManagedIdentity '${{ parameters.aksManagedIdentityName}}'
      -AdminGroupObjectId '$(Identity.adminGroupObjectId)'
      -UpgradeChannel '${{ parameters.upgradeChannel}}'
      -NodeOSUpgradeChannel '${{ parameters.NodeOSUpgradeChannel}}'      
    FailOnStandardError: true
    azurePowerShellVersion: LatestVersion
    pwsh: true
----------------------------------------------
parameters:
  - name: azureSubscription
    type: string
  - name: aksResourceGroupName
    type: string
  - name: aksClusterName
    type: string
  - name: osType
    type: string
  - name: workerNodeVMSize
    type: string
  - name: location
    type: string
  - name: agentPoolname
    type: string
  - name: vnetResourceGroupName
    type: string
  - name: vnetName
    type: string
  - name: subnetName
    type: string
  - name: agentCount
    type: number
  - name: maxPods
    type: number
    default: 30

steps:

- task: AzureResourceGroupDeployment@2
  displayName: 'Create Node Pool'
  inputs:
    azureSubscription: '${{ parameters.azureSubscription }}'
    resourceGroupName: '${{ parameters.aksResourceGroupName }}'
    location: '${{ parameters.location }}'
    csmFile: '$(System.DefaultWorkingDirectory)/arm/aksAddAgentpool.json'
    overrideParameters: '
      -clusterName "${{ parameters.aksClusterName }}"
      -location "${{ parameters.location }}"
      -agentPoolName "${{ parameters.agentPoolname }}"
      -workerNodeVMSize "${{ parameters.workerNodeVMSize }}"
      -osType "${{ parameters.osType }}"
      -virtualNetworkRGName "${{ parameters.vnetResourceGroupName }}"
      -virtualNetworkName "${{ parameters.vnetName }}"
      -subnetName "${{ parameters.subnetName }}"
      -agentCount ${{ parameters.agentCount }}
      -maxPods ${{ parameters.maxPods }}'
----------------------------------
parameters:
  - name: azureSubscription
    type: string
  - name: aksResourceGroupName
    type: string
  - name: aksClusterName
    type: string
  - name: namespace
    type: string
  - name: manifestFile
    type: string

steps:
- task: Kubernetes@1
  displayName: 'kubectl create namespace'
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: '${{ parameters.azureSubscription }}'
    azureResourceGroup: '${{ parameters.aksResourceGroupName }}'
    kubernetesCluster: '${{ parameters.aksClusterName }}'
    useClusterAdmin: true
    outputFormat: 'yaml'
    command: apply
    useConfigurationFile: true
    configurationType: inline
    inline: |
      apiVersion: v1
      kind: Namespace
      metadata:
        name: ${{ parameters.namespace }}
- task: Kubernetes@1
  displayName: 'kubectl apply'
  inputs:
    connectionType: 'Azure Resource Manager'
    azureSubscriptionEndpoint: ${{ parameters.azureSubscription }}
    azureResourceGroup: ${{ parameters.aksResourceGroupName }}
    kubernetesCluster: ${{ parameters.aksClusterName }}
    useClusterAdmin: true
    outputFormat: 'yaml'
    namespace:  ${{ parameters.namespace }}
    command: apply
    useConfigurationFile: true
    configuration:  ${{ parameters.manifestFile }}
    arguments: --wait
----------------------------
parameters:
  - name: azureSubscription
    type: string
  - name: aksClusterName
    type: string
  - name: applicationGatewayName
    type: string
  - name: certsKeyVaultName
    type: string
  - name: aksKeyVaultLocation
    type: string
  - name: aksResourceGroupName
    type: string
  - name: repositoryRoot
    type: string
    default: "."

steps:
  - task: AzureCLI@2
    displayName: "Remove cluster and application gateway"
    condition: always()
    name: CertificatesKeyVault
    inputs:
      scriptType: "pscore"
      azureSubscription: "${{ parameters.azureSubscription }}"
      scriptLocation: inlineScript
      inlineScript: |
        $ResourceGroupName = "${{ parameters.aksResourceGroupName }}"
        $KubernetesClusterName = "${{ parameters.aksClusterName }}"
        $ApplicationGatewayName = "${{ parameters.applicationGatewayName }}"
        $RepositoryRoot = "${{ parameters.repositoryRoot }}"

        $aksCheck = az aks list --query "[?name=='$KubernetesClusterName']" | ConvertFrom-Json
        $aksExists = $aksCheck.Length -gt 0
        if ($aksExists) {
          az aks delete -n $KubernetesClusterName -g $ResourceGroupName --no-wait --yes

        }else{
          Write-Host "Cluster already deleted"
        }
      failOnStandardError: false
      continueOnError: false

  - task: AzurePowerShell@5
    displayName: "Remove Application Gateway"
    condition: always()
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      ScriptPath: ${{ parameters.repositoryRoot }}/powershell/Remove-ApplicationGateway.ps1
      ScriptArguments:
        -ResourceGroupName '${{ parameters.aksResourceGroupName }}'
        -ApplicationGatewayName '${{ parameters.applicationGatewayName }}'
        -RemoveRelatedServices $true
        -KeyVaultName '${{parameters.certsKeyVaultName}}'
      FailOnStandardError: true
      azurePowerShellVersion: LatestVersion
      pwsh: true

  - task: AzurePowerShell@5
    displayName: "Soft delete Keyvault"
    condition: always()
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      ScriptType: InlineScript
      Inline: |
        try {
          $KeyVaultInfo = Get-AzKeyVault -Name '${{parameters.certsKeyVaultName}}' -ResourceGroupName '${{ parameters.aksResourceGroupName }}'
          if ([string]::IsNullOrEmpty($KeyVaultInfo)) {
              Write-Host "Keyvault has already been deleted"
          } 
          else {
            Remove-AzKeyVault -Name '${{parameters.certsKeyVaultName}}' -ResourceGroupName '${{ parameters.aksResourceGroupName }}' -Force
            Write-Host "Keyvault has been deleted"
          }
        }
        catch {
          $ErrorMessage = $_.Exception.Message
          Write-Error "Error in removing keyvault: $ErrorMessage"
        }
      azurePowerShellVersion: LatestVersion
      pwsh: true

  - task: AzurePowerShell@5
    displayName: "Clean up Resource group"
    condition: always()
    inputs:
      azureSubscription: "${{ parameters.azureSubscription }}"
      ScriptType: InlineScript
      Inline: |
        try {
          Remove-AzResourceGroup -Name "${{ parameters.aksResourceGroupName }}" -Force
        }
        catch {
          $ErrorMessage = $_.Exception.Message
          Write-Error "Error removing resource group: $ErrorMessage"
        }
      azurePowerShellVersion: LatestVersion
      pwsh: true
-------------------------------
trigger: none

name: CCoE AKS extra Nodepool Deployment

parameters:
- name: azureSubscription
  type: string
- name: aksResourceGroupNamePrefix
  displayName: Provide the name of the resoruce group of the target AKS cluster without the suffix '-rg'
  type: string
# - name: extraNodePool
#   displayName: Extra nodepool - Only fill below fields if you also select this box. Otherwise leave field with default values.
#   type: boolean
#   default: true
- name: extraNodepoolName
  displayName:  Nodepool name - Max 6 characters
  type: string
  default: 'empty'
- name: nodePoolOsType
  type: string
  values:
  - 'Linux'
  - 'Windows'
  default: 'Linux'
  displayName: Provide the operating system of the User nodepool.  
- name: location
  type: string
  default: 'westeurope'
  values:
  - 'westeurope'
  - 'northeurope'
  - 'westus2'
  - 'westus'
  - 'eastus2'
  - 'centralus'
  - 'westcentralus'
  - 'koreacentral'  
  - 'japaneast'
  - 'japanwest'
  displayName: Provide the location where the AKS cluster exists
- name: environment
  type: string
  default: 'dta'
  values:
  - 'dta'
  - 'eng'
  - 'dev'
  - 'tst'
  - 'prd'
  displayName: Provide the enviroment of the cluster  
- name: virtualNetworkRGName
  type: string
  default: 'empty'
  displayName: Provide the Virtual Network Resourcegroup Name
- name: virtualNetworkName
  type: string
  default: 'empty'
  displayName: Provide the Virtual Network  Name  
- name: aksSubnetName
  type: string
  default: 'empty'
  displayName: AKS Subnet name - Provide the subnetname where the nodepool need to connect to.
- name: agentCount
  type: number
  default: 2
  displayName: Provide the agent count
- name: workerNodeVMSize
  type: string
  default: 'Standard_E4s_v3'
- name: maxPods
  type: number
  default: 30

# - name: extraNamespace
#   displayName: Extra namespace -  Fill below fields ONLY IF you also select this box.  Otherwise leave field with default values.
#   type: boolean
#   default: true
# - name: extraNamespaceName
#   displayName: Provide the name of  Extra Namespace
#   type: string
#   default: 'empty'
# - name: customerResourceGroupNamePrefix
#   type: string
#   displayName: Customer RG prefix name - Provide the Customer resource group prefix (without -rg).
#   default: 'empty'
# - name: projectName
#   type: string
#   displayName: Project name - Provide the Customers Azure DevOps Project name.
#   default: 'empty'

stages:

- stage: create_nodepool
  displayName: Create AKS Nodepool
  jobs:
  - job:
    pool:
      vmImage: 'windows-latest'
    variables:
      AksClusterName: '${{ parameters.aksResourceGroupNamePrefix }}-cl'
      AksResourceGroupName: '${{ parameters.aksResourceGroupNamePrefix }}-rg'
    steps:
    - template: '../templates/aks-create-nodepool.yml'
      parameters:
        AzureSubscription: '${{ parameters.azureSubscription }}'
        AksResourceGroupName: "$(AksResourceGroupName)"
        AksClusterName: "$(AksClusterName)"
        osType: '${{ parameters.nodePoolOsType }}'
        WorkerNodeVMSize: '${{ parameters.workerNodeVMSize }}'
        Location: '${{ parameters.location }}'
        AgentPoolname: '${{ parameters.extraNodepoolName }}'
        VnetResourceGroupName: '${{ parameters.virtualNetworkRGName }}'
        VnetName: '${{ parameters.virtualNetworkName }}'
        SubnetName: '${{ parameters.aksSubnetName }}'
        AgentCount: '${{ parameters.agentCount }}'
        MaxPods: '${{ parameters.maxPods }}'


# - stage: create_namespace
#   displayName: Create AKS Namespace
#   condition: ne('${{ parameters.extraNamespace }}', 'false')
#   jobs:
#   - job: job_create_namespace
#     pool: CCoE-SharedAgents-Rhel7.9
#     variables:
#       AksClusterName: '${{ parameters.aksResourceGroupNamePrefix }}-cl'
#       AksResourceGroupName: '${{ parameters.aksResourceGroupNamePrefix }}-rg'
#     steps:
#     - template: '../templates/aks-create-namespace.yml'
#       parameters:
#         AzureSubscription: '${{ parameters.azureSubscription }}'
#         AksResourceGroupNamePrefix: '${{ parameters.aksResourceGroupNamePrefix }}'
#         AksClusterName: "$(AksClusterName)"
#         AksNameSpaceName: '${{ parameters.extraNamespaceName }}'
#         ServiceName: '${{ parameters.extraNamespaceName }}'
#         ADGroup: '${{ parameters.customerResourceGroupNamePrefix }}-Contributor' # group that will get full access to the namespace
#         Environment: '${{ parameters.environment }}'
#         SkipCreateNamespace: false
#         SkipFullNamespaceRole: false
#         SkipSPRoleBinding: false
#         SkipADGroupRoleBinding: false
#         SkipADGroupRoleBindingDashBoard: false
-----------------------------------------------------------
trigger: none

name: CCoE AKS Infrastructure Deployment

parameters:
- name: azureSubscription
  type: string
  default: 'asml-dta01-<servicename>'
  displayName: "Name of the Azure subscription"
- name: aksClusterSKUTier
  type: string
  default: 'Free'
  values:
  - 'Free'
  - 'Standard'
  - 'Premium'
  displayName: "AKS SKU Tier"    
- name: location
  type: string
  default: 'westeurope'
  values:
  - 'westeurope'
  - 'northeurope'
  - 'westus'
  - 'westus2'
  - 'westus3'
  - 'eastus2'
  - 'centralus'
  - 'westcentralus'
  - 'japaneast'
  - 'japanwest'
  displayName: "Azure Region"
- name: environment
  type: string
  values:
  - 'dta'
  - 'prd'
  default: 'dta'
  displayName: "environment, dev-test-acc or production"
- name: aksNetworkPluginMode
  type: string
  values:
  - 'cni'
  - 'overlay'
  default: 'overlay'
  displayName: "Select network plugin for CNI. Overlay or CNI "      
- name: kubernetesVersion
  type: string
  default: '1.22'
  displayName: "AKS cluster version"  
- name: serviceName
  displayName: "Name of the service which will run on the cluster"
  type: string
  default: '<serviceName>'
- name: aksResourceGroupNamePrefix
  type: string
  default: 'aks-euwe-dta01'
  displayName: "Name of the AKS ResourceGroupName Prefix without the -rg suffix. If you BYO appgw certificate, the KV resource group is taken as AKS RG"  
- name: virtualNetworkRGName
  type: string
  default: 'vneteuwe-<servicename>-dta01-rg'
  displayName: "Name of the Resource Group where the Virtual Network resides"
- name: virtualNetworkName
  type: string
  default: 'dta01-<serviceName>-westeurope-vnet'
  displayName: "Name of the Virtual Network to be used"
- name: aksSubnetName
  type: string
  default: 'aks01-subnet'
  displayName: "Name of the subnet to be used by the cluster"
- name: aksAutoUpgradeMethod
  type: string
  values:
  - 'none'
  - 'patch'
  - 'stable'
  - 'rapid'
  - 'node-image'  
  default: 'stable'
  displayName: "AKS Cluster Auto upgrade method"   
- name: aksNodeOSAutoUpgradeMethod
  type: string
  values:
  - 'NodeImage'
  - 'SecurityPatch'
  - 'Unmanaged'
  - 'None'
  default: 'NodeImage'
  displayName: "AKS Node OS Auto upgrade method"        
- name: applicationGatewaySubnetName
  type: string
  default: 'appgw01-subnet'
  displayName: "Name of the subnet to be used by the Application Gateway"
- name: agPrivateIp
  type: string
  default: '10.xx.xx.xx'
  displayName: "Internal IP to be used by the Application Gateway"
- name: dnsServiceIP
  type: string
  default: '10.xx.xx.xx'
  displayName: "Internal DNS server for AKS"
- name: serviceCidr
  type: string
  default: '10.xx.xx.xx/xx'
  displayName: "ServiceCidr - IP range for AKS services"
- name: agentCount
  type: number
  default: 2
  displayName: "Number of worker node instances"
- name: workerNodeVMSize
  type: string
  default: 'Standard_E4s_v3'
  displayName: "VM size for standard nodepool"
- name: maxPods
  type: number
  default: 30
  displayName: "Max number of schedulable pods on nodes in standard nodepool"
- name: shouldAppgwCertificateImported
  type: boolean
  default: false
  displayName: "Do you want to use your own appgw certificate instead of self-signed?"
- name: keyVaultResourceGroupNamePrefix
  type: string
  default: 'Empty'
  displayName: "Name of the ResourceGroup containing Keyvault holding appgw certificate. Prefix without the -rg suffix. Provide only if shouldAppgwCertificateImported is true. This will be used as AKS RG"
- name: keyVaultBaseName
  type: string
  default: 'Empty'
  displayName: "Name of the Keyvault which holds the appgw certificate. Provide only if shouldAppgwCertificateImported is true"
- name: keyVaultAppGWCertificateName
  type: string
  default: 'Empty'
  displayName: "Certificate name in KV for application gateway. Provide only if shouldAppgwCertificateImported is true"    

variables:
  ${{ if eq( parameters['shouldAppgwCertificateImported'], true ) }}:
    aksClusterName: '${{ parameters.keyVaultResourceGroupNamePrefix }}-cl'
  ${{ elseif eq( parameters['shouldAppgwCertificateImported'], false )  }}:
    aksClusterName: '${{ parameters.aksResourceGroupNamePrefix }}-cl'
  ${{ if eq( parameters['shouldAppgwCertificateImported'], false ) }}:
    aksResourceGroupName: '${{ parameters.aksResourceGroupNamePrefix }}-rg'
    aksResourceGroupNamePrefix: '{{ parameters.aksResourceGroupNamePrefix }}'
    aksKeyVaultBaseName: '${{ variables.aksClusterName }}'
    appGatewayCertificateName: '${{ variables.aksClusterName }}-appgw-cert'    
  ${{ else }}:
    aksResourceGroupName: '${{ parameters.keyVaultResourceGroupNamePrefix }}-rg'
    aksResourceGroupNamePrefix: '{{ parameters.keyVaultResourceGroupNamePrefix }}'
    aksKeyVaultBaseName: '${{ parameters.keyVaultBaseName }}'
    appGatewayCertificateName: '${{ parameters.keyVaultAppGWCertificateName }}'
  agentPoolName: 'standard'
  aksNodePoolResourceGroupName: 'MC_${{ variables.aksResourceGroupName }}_${{ variables.aksClusterName }}_${{ parameters.location}}'
  agName: '${{ parameters.aksResourceGroupNamePrefix }}-ag'
  aksStandardNodePoolOsType: 'Linux'
  networkPolicy: 'calico'
  aksManagedIdentityName: '${{ parameters.aksResourceGroupNamePrefix }}-aks-uami'
  aksNetworkPlugin: 'azure'
  AdminUsername: 'asml-aksadmin'
  appgwManagedIdentityName: '${{ parameters.aksResourceGroupNamePrefix }}-ag-uami'
  AppGatewaySKUTier: Standard_v2  
  AppGatewaySKU: 'Medium'
  zones: '1,2,3'
  WafEnabled: False
  WafMode: 'Prevention'
  WafRuleSetType: 'OWASP'
  WafRuleSetVersion: '3.0'  


resources:
  repositories:
  - repository: ccoe-az-application-gateway
    type: git
    name: CCoE\ccoe-az-application-gateway
  - repository: ccoe-az-key-vault
    type: git
    name: CCoE\ccoe-az-key-vault
  - repository: ccoe-az-common
    type: git
    name: CCoE\ccoe-az-common

stages:
- stage: validate_input_parameters
  displayName: Validate the input parameters
  jobs: 
  - job: job_validate_input_parameters
    pool:
      vmImage: 'windows-latest'
    variables:
      aksLocation: '${{ parameters.location }}'
      aksInputVersion: '${{ parameters.kubernetesVersion }}'    
    steps:
    - task: AzurePowerShell@5
      displayName: 'Check the provided kubernetes version'
      name: ValidateVersion
      inputs:
        ConnectedserviceNameARM: ${{ parameters.azureSubscription }}
        ScriptType: InlineScript
        Inline: |
          Install-Module -Name 'Az.Aks' -Force
          Import-Module -Name 'Az.Aks'          
          Write-Host "Input AKS version provided: $(aksInputVersion) "
          $availableVersions = Get-AzAksVersion -Location "$(aksLocation)"|where-object IsPreview -ne "True"
          Write-Host "Available versions for this region"
          Write-Host $availableVersions
          [version]$inputVersion = "$(aksInputVersion)"
          $versionPresent = $false
          foreach($version in $availableVersions) {
            [version]$supportedversion = $version.OrchestratorVersion
            if ($supportedversion.Major -eq $inputVersion.Major )
            { 
              if( $supportedversion.Minor -eq $inputVersion.Minor ) 
              {
                if ($supportedversion.Build -eq $inputVersion.Build ) 
                {
                  $versionPresent = $true
                  $AKSVersion = ($supportedversion).toString()
                } elseif ( $inputVersion.Build -eq -1 ) 
                {
                  $AKSVersion = ($availableVersions.OrchestratorVersion[$availableVersions.Length-2]).toString()
                }
              }
            }
          }

          if(! $versionPresent ) {
            $AKSVersion = ($availableVersions.OrchestratorVersion[$availableVersions.Length-1]).toString()
          }

          Write-Host "Setting AKS Version: $AKSVersion"
          Write-Output "##vso[task.setvariable variable=AKSVersion;isOutput=true;]$AKSVersion"
        azurePowerShellVersion: LatestVersion
        pwsh: true
        
- stage: create_aks_resource_group
  displayName: Create AKS Resource Group
  dependsOn:
   - validate_input_parameters  
  jobs:
  - job: job_create_aks_resource_group
    steps:
    - checkout: ccoe-az-common
      path: s/ccoe-az-common
    - task: AzurePowerShell@5
      displayName: 'Create Resource Group'
      condition: eq('${{ parameters.shouldAppgwCertificateImported}}', false)
      inputs:
        azureSubscription: '${{ parameters.azureSubscription }}'
        ScriptPath: '$(Agent.BuildDirectory)/s/ccoe-az-common/powershell/Create-ResourceGroup.ps1'
        ScriptArguments: '-ResourceGroupName ${{ variables.aksResourceGroupName }} -location ${{ parameters.location }}'
        errorActionPreference: continue
        azurePowerShellVersion: LatestVersion

- stage: create_aks_applicationgateway
  displayName: Create AKS Application Gateway
  dependsOn:
  - create_aks_resource_group
  jobs:
  - job: job_create_aks_applicationgateway
    pool: CCoE-SharedAgents-Rhel7.9
    variables:
      serviceName: ${{ parameters.serviceName }}
      aksResourceGroupName: ${{ variables.aksResourceGroupName }}
      certificateName: '${{ variables.appGatewayCertificateName }}'
      publicIPName: '${{ variables.agName }}-pub-ip'
      PermissionsToSecrets: get, list, set, delete, backup, restore, recover, purge
      PermissionsToKeys: encrypt, decrypt, wrapKey, unwrapKey, sign, verify, get, list, create, update, import, delete, backup, restore, recover, purge
      PermissionsToCertificates: get, list, delete, create, import, update, managecontacts, getissuers, listissuers, setissuers, deleteissuers, manageissuers, recover, purge
    steps:
    - checkout: self
      path: s/self
    - checkout: ccoe-az-application-gateway
      path: s/ccoe-az-application-gateway
    - checkout: ccoe-az-key-vault
      path: s/ccoe-az-key-vault
    - task: AzurePowerShell@5
      name: AADGroup
      displayName: 'Formulate admin AAD group'
      condition: succeeded()
      inputs:
        azureSubscription: '${{ parameters.azureSubscription }}'
        ScriptType: InlineScript
        Inline: |
          try {
            if (Get-Module -ListAvailable -Name 'Az.Accounts') {
                Write-Host "Az Accounts Module exists"
            } 
            else {
              Install-Module -Name 'Az.Accounts' -RequiredVersion '2.13.2' -Force
              Import-Module -Name 'Az.Accounts'
            }

            if (Get-Module -ListAvailable -Name 'Az.Resources') {
                Write-Host "Az Resources Module exists"
            } 
            else {
              Install-Module -Name 'Az.Resources' -Force
              Import-Module -Name 'Az.Resources'
            }
            $subscriptionName = (Get-AzContext).Subscription.Name
            Write-Host "Subscription name: $subscriptionName"
            $subscriptionNameArray = $subscriptionName.Split('-')

            $subscriptionNameArray[1] = $subscriptionNameArray[1] -replace '\d', ''
            if( $subscriptionNameArray[1]  -eq 'dta' ){
              $adminGroupName = ($subscriptionNameArray -join '-') + "-Contributor"
            } elseif ($subscriptionNameArray[1] -eq 'prd' ){
              $adminGroupName = ($subscriptionNameArray -join '-') + "-Reader"
            }
            Write-Host "Admin group name is: $adminGroupName"
            $adminGroupObjectId = (Get-AzADGroup -DisplayNameStartsWith $adminGroupName).Id
            Write-Output "##vso[task.setvariable variable=adminGroupObjectId]$($adminGroupObjectId)"        
          }
          catch {
            $ErrorMessage = $_.Exception.Message
            Write-Error "Error fetching AAD group with message: $ErrorMessage"        
          }
        FailOnStandardError: true
        azurePowerShellVersion: LatestVersion
        pwsh: true

    - task: AzurePowerShell@5
      name: RandomStringKV
      displayName: Create a new KV name with a random string
      condition: succeeded()
      inputs:
        azureSubscription: '${{ parameters.azureSubscription }}'
        ScriptType: InlineScript
        Inline: |
          $randomString = -join ((48..57) + (97..122) | Get-Random -Count 5 | % {[char]$_})
          $newAksKeyVaultBaseName = "${{ variables.aksKeyVaultBaseName }}" + $randomString
          $newAksKeyVaultName = $newAksKeyVaultBaseName + "-kv"
          Write-Host "the new key vault name is $($newAksKeyVaultName)"
          Write-Output "##vso[task.setvariable variable=newAksKeyVaultName;isOutput=true;]$newAksKeyVaultName"
          Write-Output "##vso[task.setvariable variable=newAksKeyVaultBaseName]$($newAksKeyVaultBaseName)"
        azurePowerShellVersion: LatestVersion
        pwsh: true

    # Create and Set KV access for Self signed certificate        
    - ${{ if eq(parameters.shouldAppgwCertificateImported, false ) }}:    
      - template: devops/templates/create-key-vault.yml@ccoe-az-key-vault
        parameters:
          AzureSubscription: '${{ parameters.azureSubscription }}'
          ResourceGroupName: $(aksResourceGroupName)
          Location: '${{ parameters.location}}'
          KeyVaultName:  $(newAksKeyVaultBaseName)
          EnableVaultForDeployment: true
          EnableVaultForDiskEncryption: true
          EnableVaultForTemplateDeployment: true
          EnableRbacAuthorization: false
          Bypass: AzureServices
          DefaultAction: Allow                    
          RepositoryRoot: "$(Agent.BuildDirectory)/s/ccoe-az-key-vault"

    - ${{ if eq(parameters.shouldAppgwCertificateImported, false ) }}:  
      - template: devops/templates/create-key-vault-certificate.yml@ccoe-az-key-vault
        parameters:
          AzureSubscription: '${{ parameters.azureSubscription }}'
          KeyVaultName:  $(RandomStringKV.newAksKeyVaultName)
          RepositoryRoot: "$(Agent.BuildDirectory)/s/ccoe-az-key-vault"
          ContentType: "application/x-pkcs12"
          DNSName: "asml"
          Subject: "CN=asml"
          CertificateName: '${{ variables.appGatewayCertificateName }}'

    # Set KV access for imported certificate
    - ${{ if eq(parameters.shouldAppgwCertificateImported, true ) }}:  
      - template: devops/templates/set-key-vault-access-policy.yml@ccoe-az-key-vault
        parameters:
          AzureSubscription: '${{ parameters.azureSubscription }}'
          KeyVaultName:  $(RandomStringKV.newAksKeyVaultName)
          AccessObjectIdList: $(adminGroupObjectId)
          PermissionsToSecrets: $(PermissionsToSecrets)
          PermissionsToKeys: $(PermissionsToKeys)
          PermissionsToCertificates: $(PermissionsToCertificates)
          RepositoryRoot: "$(Agent.BuildDirectory)/s/ccoe-az-key-vault"

    - task: AzurePowerShell@5
      displayName: 'Create Public IP for appgw'
      name: NetworkConfig
      inputs:
        azureSubscription: '${{ parameters.azureSubscription }}'
        ScriptType: InlineScript
        Inline: |
          $Vnet = Get-AzVirtualNetwork -Name ${{ parameters.virtualNetworkName }} -ResourceGroupName ${{ parameters.virtualNetworkRGName }}
          $PipResourceIdStandard = New-AzPublicIpAddress -Name $(publicIpName) -ResourceGroupName $(aksResourceGroupName) -AllocationMethod Static -Sku Standard -Location ${{ parameters.location }} -Force
          Write-Output "##vso[task.setvariable variable=PublicIpAddressResourceId]$($PipResourceIdStandard.Id)"
          Write-Output "##vso[task.setvariable variable=VirtualNetworkResourceId]$($Vnet.Id)"
        azurePowerShellVersion: LatestVersion
        pwsh: true
    - template: devops/templates/create-application-gateway.yml@ccoe-az-application-gateway
      parameters:
        AzureSubscription: ${{ parameters.azureSubscription }}
        ResourceGroupName: '$(aksResourceGroupName)'
        Location: '${{ parameters.location}}'
        AppGatewayName: '${{ variables.agName }}'
        AppGatewaySKUTier: ${{ variables.AppGatewaySKUTier }}
        AppGatewaySKU: ${{ variables.AppGatewaySKU }}
        KeyVaultName:  $(RandomStringKV.newAksKeyVaultName)
        isGeneratedCertificate: True
        CertificateName: '${{ variables.appGatewayCertificateName }}'
        AppgwManagedIdentityName: '${{ variables.appgwManagedIdentityName }}'
        Capacity: 2
        MinCapacity: 2
        MaxCapacity: 10
        VirtualNetworkResourceId: $(VirtualNetworkResourceId)
        SubnetName: '${{ parameters.applicationGatewaySubnetName }}'
        FrontendIpAddress: ${{ parameters.agPrivateIp }}
        PublicIpAddressResourceId: $(PublicIpAddressResourceId)
        Zones: ${{ variables.zones }}
        WafEnabled: ${{ variables.WafEnabled }}
        WafMode: ${{ variables.WafMode }}
        WafRuleSetType: ${{ variables.WafRuleSetType }}
        WafRuleSetVersion: ${{ variables.WafRuleSetVersion }}
        RepositoryRoot: "$(Agent.BuildDirectory)/s/ccoe-az-application-gateway"

- stage: create_aks_cluster
  displayName: Create AKS Cluster
  dependsOn:
  - validate_input_parameters
  - create_aks_resource_group
  - create_aks_applicationgateway
  jobs:
  - job:
    pool: CCoE-SharedAgents-Rhel7.9
    variables:
      aksResourceGroupName: ${{ variables.aksResourceGroupName }}
      aksResourceGroupNamePrefix: '${{ parameters.aksResourceGroupNamePrefix }}'
      aksClusterName: '${{ variables.aksClusterName }}'
      aksNodePoolResourceGroupName: '${{ variables.aksNodePoolResourceGroupName }}'
      applicationGatewayName: '${{ variables.agName }}'
      aksManagedIdentityName: '${{ variables.aksManagedIdentityName }}'
      aksVersion: $[stageDependencies.validate_input_parameters.job_validate_input_parameters.outputs['ValidateVersion.AKSVersion']]
      aksKeyVaultName: $[stageDependencies.create_aks_applicationgateway.job_create_aks_applicationgateway.outputs['RandomStringKV.newAksKeyVaultName']]

    steps:
    - task: AzurePowerShell@5
      displayName: 'Check Application Gateway status'
      condition: succeeded()
      inputs:
        ConnectedserviceNameARM: ${{ parameters.azureSubscription }}
        ScriptType: InlineScript
        Inline: |
          $Count = 0
          while($true) {
            $AppGw = Get-AzApplicationGateway -Name "$(applicationGatewayName)" -ResourceGroupName "$(aksResourceGroupName)"
            if ($AppGw.OperationalState -eq "Running" -Or $Count -ge 5 ) {
              break
            } else {
              Start-Sleep -Seconds 60
              $Count+=1
            }
          }
        azurePowerShellVersion: LatestVersion
        pwsh: true
    - template: '../../devops/templates/aks-admin-key-credential.yml'
      parameters:
        azureSubscription: '${{ parameters.azureSubscription }}'
        aksClusterName: '$(aksClusterName)'
        aksKeyVaultName: '$(aksKeyVaultName)'
    - template: '../../devops/templates/aks-create-cluster-mi.yml'
      parameters:
        agentCount: '${{ parameters.agentCount }}'
        agentPoolName: '$(agentPoolName)'
        aksClusterName: '$(aksClusterName)'
        aksClusterSKUTier: '${{ parameters.aksClusterSKUTier }}'        
        aksNetworkPlugin: '${{ variables.aksNetworkPlugin }}'
        aksNetworkPluginMode: '${{ parameters.aksNetworkPluginMode }}'                  
        aksNodePoolResourceGroupName: '$(aksNodePoolResourceGroupName)'
        aksOSType: '$(aksStandardNodePoolOsType)'
        aksResourceGroupName: '$(aksResourceGroupName)'
        aksResourceGroupNamePrefix: '$(aksResourceGroupNamePrefix)'
        azureSubscription: '${{ parameters.azureSubscription }}'
        KubernetesVersion: '$(aksVersion)'
        linuxAdminUsername: '${{ variables.AdminUsername }}'
        SshRsaPublicKey: '$(Credential.SshRsaPublicKey)'
        windowsAdminUsername: '${{ variables.AdminUsername}}'
        WindowsAdminPassword: '$(Credential.WindowsSecureSecret)'
        location: '${{ parameters.location }}'
        maxPods: ${{ parameters.maxPods }}
        NetworkPolicy: '$(networkPolicy)'
        DnsServiceIP: '${{ parameters.dnsServiceIP }}'      
        ServiceCidr: '${{ parameters.serviceCidr }}'
        SubnetName: '${{ parameters.aksSubnetName  }}'
        virtualNetworkName: '${{ parameters.virtualNetworkName }}'
        virtualNetworkRGName: '${{ parameters.virtualNetworkRGName }}'
        VirtualNetworkSubnetName: '${{ parameters.applicationGatewaySubnetName }}'
        WorkerNodeVMSize: '${{ parameters.workerNodeVMSize }}'
        ApplicationGatewayName: '$(applicationGatewayName)'
        aksManagedIdentityName: '$(aksManagedIdentityName)'
        UpgradeChannel: '${{ parameters.aksAutoUpgradeMethod }}'                    
        NodeOSUpgradeChannel: '${{ parameters.aksNodeOSAutoUpgradeMethod }}'

-------------------------------------

6ehCIg+/TTMbCDR9+ZPkpBBvWVlFLy/sQWoqHzpeOBkfOYqPFzO5VMlUZnsMkhNn
aHhvGi0wq5Tz22wqqLU6CPlX9Jd4Ka7wTqShXFVic0Xy7gZW3A+d4072FR8PsjNR
i1fOQIdmjGqYXBUJNYPnKYOblVi+lbUk0rq9r1/H7ig4hu52Nf1+9EMUis7wAeXE
16GuslELppaFVCd9vzSD36Ftda+G6TQx6hwb6W24bHUTOWsWrQnQyDx6EpbzRv0k
MHmBAoIBAQCwLEK3rOmg9xEJP4cBzusxjssCt2t6zZ87dYnh6hG6UigzC5lCo7jN
tQSxPL8WQp0K+YeUh63GouXAvroPtiFUGiHK1vGM86/MUkBd4wVXcySi+f9nvnkR
4RB2sQdp94uDfBv002+ZkBrtiyxcxlO0lQLRiFvS14TcGbInF1Dzkb+FUtW/dQ3E
4wfrX6wxj9xeKh/dXT/m88/XHysmfJDJT0NUutf0iIwZJrJaPCCeiPIaHGdarPms
knlmm8O4rFkyym+jiupoEOOaPOeyVo8Oz1F25WnQXK3MwqVwjJCOWP+Flbh3IYjP
v5MMxcK1NqeEyWqN0BRB/legVm9M+I87AoIBAQDE9Fts9Jq/RSbHrBn+S3OWFXYo
rxcIffm/W3na5gTEnRafr+xDNvUuxFbebK7+h2z4l2kx7c/s2cq9aoX6sG/LIdOk
5JyOoAwbkRD0rU03vi7NC+eCDCSRzT7/6dZe/jpc4BRxrTy5Myvg9s8Ald7G1J4s
iElwWxFLiaigwrkTsfEw/bZSlm4s5TlVpEfjVKCfCsJaxuhsvRevHJb2HypnZycf




<#
.SYNOPSIS
	Creates an Azure Kubernetes Service

.DESCRIPTION
	Creates an Azure Kubernetes Service in the specified resource group

.PREREQUISITES
	There should be an existing virtual network and a subnet for AKS

.OUTPUTS
    Information on the Created Resource

.PARAMETER ResourceGroupName
    Name of the Resource Group where the AKS cluster will be created

.PARAMETER ClusterName
    Name of the AKS cluster

.PARAMETER ClusterSKUTier
    SKU Tier of the AKS cluster

.PARAMETER Location
    Location for deploying the AKS

.PARAMETER VirtualNetworkName
    Name of the Virtual Network to be used

.PARAMETER VirtualNetworkRGName
    Name of the Resource Group where the Virtual Network resides

.PARAMETER SubnetName
    Name of the subnet to be used

.PARAMETER ServiceCidr
    CIDR range of IP address for AKS services

.PARAMETER DnsServiceIP
    Internal DNS seerver for AKS (EX- 172.17.0.10)

.PARAMETER OsDiskSizeGB
    Worked Node OSDisk Size in GB , default value is 0

.PARAMETER DataDiskSizeGB
    Worked Node DataDisk Size in GB , default value is 0

.PARAMETER AgentCount
    Number of worker node instances

.PARAMETER WorkerNodeVMSize
    workerNodeVMSize is the size of nodes

.PARAMETER LinuxAdminUsername
    linuxAdminUsername is the username for Linux VMs

.PARAMETER SshRSAPublicKey
    SSH key for Linux vm login

.PARAMETER OsType
    osType worker node for AKS cluster

.PARAMETER KubernetesVersion
    AKS cluster version

.PARAMETER EnableHttpApplicationRouting
    enableHttpApplicationRouting for AKS cluster

.PARAMETER NetworkPlugin
    Type of Network for AKS cluster

.PARAMETER DeploymentDebugLevel
    DeploymentDebugLevel is None

.PARAMETER nodeRGName
    Resource group name for backend nodepool

.PARAMETER EnablePodSecurityPolicy
    pod security

.PARAMETER  AgentPoolName
    agent pool name for AKS worker nodes

.PARAMETER NetworkPolicy
    network policy for pods

.PARAMETER UpgradeChannel
    aks cluster automatic upgrade channel

.PARAMETER NodeOSUpgradeChannel
    aks node os automatic upgrade channel

#>

[CmdletBinding()]

Param (

    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [String] $ClusterName,

    [Parameter(Mandatory = $true)]
    [String] $ClusterSKUTier,

    [Parameter(Mandatory = $true)]
    [ValidateSet("westeurope", "northeurope", "westus2", "westus", "westus3", "eastus2", "centralus", "westcentralus", "japaneast", "japanwest")]
    [String] $Location,

    [Parameter(Mandatory = $true)]
    [String] $VirtualNetworkRGName,

    [Parameter(Mandatory = $true)]
    [String] $VirtualNetworkName,

    [Parameter(Mandatory = $true)]
    [String] $SubnetName,

    [Parameter(Mandatory = $true)]
    [String] $ServiceCidr,

    [Parameter(Mandatory = $true)]
    [String] $DnsServiceIP,

    [Parameter(Mandatory = $false)]
    [Int] $OsDiskSizeGB,

    [Parameter(Mandatory = $false)]
    [Int] $DataDiskSizeGB,

    [Parameter(Mandatory = $true)]
    [Int] $AgentCount,

    [Parameter(Mandatory = $true)]
    [String] $WorkerNodeVMSize,

    [Parameter(Mandatory = $true)]
    [String] $LinuxAdminUsername,

    [Parameter(Mandatory = $true)]
    [String] $SshRSAPublicKey,

    [Parameter(Mandatory = $true)]
    [String] $WindowsAdminUsername,

    [Parameter(Mandatory = $true)]
    [String] $WindowsAdminPassword,

    [Parameter(Mandatory = $true)]
    [String] $OsType,

    [Parameter(Mandatory = $true)]
    [String] $KubernetesVersion,

    [Parameter(Mandatory = $true)]
    [Bool] $EnableHttpApplicationRouting,

    [Parameter(Mandatory = $true)]
    [Bool] $EnableKeyvaultSecretsProvider,

    [Parameter(Mandatory = "true")]
    [String] $EnableKeyvaultSecretsRotation,

    [Parameter(Mandatory = $true)]
    [string] $KeyvaultSecretsRotationInterval,

    [Parameter(Mandatory = $true)]
    [String] $NetworkPlugin,

    [Parameter(Mandatory = $false)]
    [String] $NetworkPluginMode,

    [Parameter(Mandatory = $true)]
    [String] $nodeRGName,

    [Parameter(Mandatory = $true)]
    [Bool] $EnablePodSecurityPolicy,

    [Parameter(Mandatory = $true)]
    [ValidatePattern({^[a-z 0-9]{0,8}$})]
    [String] $AgentPoolName,

    [Parameter(Mandatory = $true)]
    [String] $NetworkPolicy,

    [Parameter(Mandatory = $true)]
    [String] $ApplicationGatewayName,

    [Parameter(Mandatory = $true)]
    [Bool] $EnableIngressApplicationGateway,

    [Parameter(Mandatory = $true)]
    [String] $AKSManagedIdentity,

    [Parameter(Mandatory = $false)]
    [Int] $MaxPods = 30,

    [Parameter(Mandatory = $false)]
    [String] $DeploymentDebugLevel = 'None',

    [Parameter(Mandatory = $false)]
    [String] $PodCidr,

    [Parameter(Mandatory = $false)]
    [String] $AdminGroupObjectId,

    [Parameter(Mandatory = $false)]
    [String] $UpgradeChannel = 'stable',

    [Parameter(Mandatory = $false)]
    [String] $NodeOSUpgradeChannel = 'NodeImage'

)

$TemplateName = 'aksDeployMI.json'
Write-Verbose 'Creating parameters object for ARM Template.'

$ParameterARM = @{
    clusterName                      = $ClusterName
    clusterSKUTier                   = $ClusterSKUTier
    location                         = $Location
    virtualNetworkRGName             = $VirtualNetworkRGName
    virtualNetworkName               = $VirtualNetworkName
    subnetName                       = $SubnetName
    serviceCidr                      = $ServiceCidr
    dnsServiceIP                     = $DnsServiceIP
    osDiskSizeGB                     = $OsDiskSizeGB
    dataDiskSizeGB                   = $DataDiskSizeGB
    agentCount                       = $AgentCount
    workerNodeVMSize                 = $WorkerNodeVMSize
    linuxAdminUsername               = $LinuxAdminUsername
    sshRSAPublicKey                  = $SshRSAPublicKey
    windowsAdminUsername             = $WindowsAdminUsername
    windowsAdminPassword             = $WindowsAdminPassword
    osType                           = $OsType
    kubernetesVersion                = $KubernetesVersion
    enableKeyvaultSecretsProvider    = $EnableKeyvaultSecretsProvider
    enableKeyvaultSecretsRotation    = $EnableKeyvaultSecretsRotation
    keyvaultSecretsRotationInterval  = $KeyvaultSecretsRotationInterval
    enableHttpApplicationRouting     = $EnableHttpApplicationRouting
    networkPlugin                    = $NetworkPlugin
    nodeRGName                       = $nodeRGName
    enablePodSecurityPolicy          = $EnablePodSecurityPolicy
    agentPoolName                    = $AgentPoolName
    networkPolicy                    = $NetworkPolicy
    networkPluginMode                = $NetworkPluginMode
    applicationGatewayName           = $ApplicationGatewayName
    enableIngressApplicationGateway  = $EnableIngressApplicationGateway
    maxPods                          = $MaxPods
    podCidr                          = "$PodCidr"
    aksManagedIdentity               = $AKSManagedIdentity
    adminGroupObjectID               = $AdminGroupObjectId
    upgradeChannel                   = $UpgradeChannel
    nodeOSUpgradeChannel             = $NodeOSUpgradeChannel
}

Write-Host 'Get template for AKS.'

$TemplateFile = Join-Path -Path $PSScriptRoot -ChildPath "..\arm\$TemplateName"
$TemplateName = (Get-ChildItem $TemplateFile).BaseName
$DeploymentName = "ARM-deployment-$( -join ((0x30..0x39) + ( 0x41..0x5A) + ( 0x61..0x7A) | Get-Random -Count 48  | ForEach-Object {[char]$_}) )"

$DeploymentParams = @{
    Name                    = $DeploymentName
    ResourceGroupName       = $ResourceGroupName
    TemplateFile            = $TemplateFile
    TemplateParameterObject = $ParameterARM
    DeploymentDebugLogLevel = $DeploymentDebugLevel
    ErrorVariable           = 'errorMessages'
    ErrorAction             = 'SilentlyContinue'
    Verbose                 = $true
}

Write-Verbose 'Deploying ARM Template.'
New-AzResourceGroupDeployment @DeploymentParams -DeploymentDebugLogLevel All

If ($errorMessages) {
    Write-Error "Template deployment returned the following errors: $errorMessages"
}
--------------------------------------
<#
.SYNOPSIS
Validate AKS environment

.DESCRIPTION
Test-AksDeployment validates the deployment of an AKS cluster.

.EXAMPLE
Test-AksDeployment

This command will validate the AKS cluster.
#>
[CmdletBinding()]
Param(
    [Parameter(
        Mandatory = $true,
        HelpMessage = 'AKS cluster name')]
    [string] $AksClusterName,
    [Parameter(
        Mandatory = $true,
        HelpMessage = 'AKS resource group name')]
    [string] $AksResourceGroupName
)
$ErrorView = 'NormalView'

$SubscriptionId = $(az account show --query id -o tsv)
Write-Output "Subscription Id: $SubscriptionId"

$SubscriptionName = $(az account show --query name -o tsv)
Write-Output "Subscription Name: $SubscriptionName"

$TenantId = $(az account show --query tenantId -o tsv)
Write-Output "Tenant Id: $TenantId"

$Username = $(az account show --query user.name -o tsv)
Write-Output "Service Principal Name or ID: $Username"

# Relative path for kube config file
$KubeConfigPath = "./.kube/config"

Write-Output "Get credentials and set up for kubectl to use"
az aks get-credentials -g "$AksResourceGroupName" -n "$AksClusterName" -a -f "$KubeConfigPath"

Write-Output "Get kubectl version info"
kubectl --kubeconfig "$KubeConfigPath" version short

$KubectlOutput = (kubectl get pods -o json)
Write-Host "Kubectl output"
Write-Host $KubectlOutput
$Data = $KubectlOutput | ConvertFrom-Json

ForEach ($Item in $Data.items) {
    Write-Host "Ingress: "$Item.metadata.name

    ForEach ($ContStatus in $Item.status.containerStatuses) {
        Write-Host " > Checking: $($ContStatus.name)"
        if ($ContStatus.ready -eq $false) {
            throw "Failure: $($ContStatus.name) is not ready";
        }
        Write-Host "$($ContStatus.name) is ready"
    }
}

Write-Output "Remove kubectl config file"
Remove-Item -Path "$KubeConfigPath"
----------------------------------------------------------

<#
.SYNOPSIS
Validate connectivity

.DESCRIPTION
Test-Connectivity tests the connectivity to an AKS cluster.

.EXAMPLE
Test-Connectivity

This command will test the connectivity to an AKS cluster.
#>
[CmdletBinding()]
Param(
    [Parameter(
        Mandatory = $true,
        HelpMessage = 'URL to call')]
    [string] $UrlToTest,
    [Parameter(
        Mandatory = $false,
        HelpMessage = 'Times to retry')]
    [Int]  $RetryTimes = 100,
    [Parameter(
        Mandatory = $false,
        HelpMessage = 'Seconds to wait between attempts')]
    [Int]  $WaitTime = 10
)
$ErrorView = 'NormalView'

for ($Attempt = 1; $Attempt -lt $Retrytimes + 1; $Attempt++) {
    Write-Host "Checking for connectivity to url $UrlToTest. Attempt $Attempt/$Retrytimes"

    try {
        $response = Invoke-WebRequest -Uri $UrlToTest
    }
    catch {
        Write-Host "Error: $_";
    }

    if ($response.StatusCode -eq 200) {
        Write-Host "Connectivity test successful"
        break
    }
    else {
        if ($Attempt -eq $Retrytimes) {
            throw "Connectivity test unsuccessful"
        }
        else {
            Write-Host "Waiting $WaitTime seconds for connectivity..."
            Start-Sleep -Seconds $WaitTime
        }
    }
}
-------------------------------------------------------------------
<#
.SYNOPSIS
	Removes an Application Gateway.

.DESCRIPTION
	Removes the specified Application Gateway in the specified resource group.

.PREREQUISITES
	The specified Application Gateway must exist. The principal executing the script must have removal permissions on the resource and owner permissions on any locks.

.OUTPUTS
	Success or error message
#>

[CmdletBinding()]
Param (
    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [String] $ApplicationGatewayName,

    [Parameter(Mandatory = $true)]
    [String] $KeyVaultName,

    [Bool] $RemoveRelatedServices

)

$ErrorActionPreference = "Stop"

Try {
    # This throws an error if the resource is not found, even if the error action is silently continue
    $AG = Get-AzApplicationGateway -Name $ApplicationGatewayName -ResourceGroupName $ResourceGroupName

    Remove-AzResource -resourceid $AG.Id -Force | Out-Null
    Write-Host "Removed Application Gateway '$ApplicationGatewayName' from resource group '$ResourceGroupName'."
    Remove-AzKeyVault -Name $KeyVaultName -ResourceGroupName $ResourceGroupName -Force
    Write-Host "Removed application gateway keyvault '$KeyVaultName'"
}
Catch {
    Write-Warning "Application Gateway '$ApplicationGatewayName' cannot be removed from '$ResourceGroupName'. $($_.Exception.Message)"
}

if ($RemoveRelatedServices -eq $true) {
    # Remove Public IP address
    foreach ($fip in $AG.FrontendIPConfigurations) {
        if ($fip.PublicIPAddress) {
            $PIPResourceID = $fip.PublicIPAddress.Id
            Try {
                # This throws an error if the resource is not found, even if the error action is silently continue
                Remove-AzResource -resourceid $PIPResourceID -Force | Out-Null
                Write-Host "Removed Public IP from resource group '$ResourceGroupName'."
            }
            Catch {
                Write-Warning "Public IP cannot be removed from '$ResourceGroupName'. $($_.Exception.Message)"
            }
        }
    }
}
---------------------------------------------------
<#
.SYNOPSIS
Removes the Kubernetes Service.

.DESCRIPTION
Removes the Kubernetes Service with the specified name from the specified resource group.

.PREREQUISITES
The specified Kubernetes Service must exist. The principal executing the script must have write permission
on the resource and 'owner' role on the resource group to be able to remove the locks.

.OUTPUTS
Success or error message
#>

[CmdletBinding()]
Param (
    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [String] $KubernetesClusterName,

    [Parameter(Mandatory = $false)]
    [Bool] $Wait = $false
)

# In case of an error, display the error message and stop execution
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Making sure module Az.Aks is installed so Remove-AzAks cmdlet is available
If (-not (Get-Module -ListAvailable -Name 'Az.Aks')) {
    Write-Host "Az.Aks is not installed, installing..."
    Install-Module -Name Az.Aks -RequiredVersion 1.0.1 -Force -Scope CurrentUser -WarningAction SilentlyContinue

    Write-Host "Import module Az.Aks."
    Import-Module -Name 'Az.Aks' -Force
}

Try {
    if ($Wait) {
        $Resource = az aks show -n $KubernetesClusterName -g $ResourceGroupName
        az aks wait --deleted -n $KubernetesClusterName -g $ResourceGroupName
    }
    else {
        az aks delete -n $KubernetesClusterName -g $ResourceGroupName
    }
}
Catch {
    Write-Warning "An error occured while checking for Kubernetes Service named '$KubernetesClusterName'. $_"
    Return
}

Write-Host "Removed Kubernetes Service with name '$KubernetesClusterName' from resource group '$ResourceGroupName'"
----------------------------------------------------------------
<#
.SYNOPSIS
	Creates a Node pool to existing Azure Kubernetes Service

.DESCRIPTION
	Creates a Node pool to existing Azure Kubernetes Service in the specified resource group

.PREREQUISITES
	There should be an existing virtual network,subnet,Azure Kubernetes Service

.OUTPUTS
    Information on the Created node pool details

.PARAMETER ResourceGroupName
    Name of the Resource Group where the AKS cluster is present

.PARAMETER ClusterName
    Name of the existing AKS cluster

.PARAMETER Location
    Location for the deployed AKS cluster

.PARAMETER VirtualNetworkName
    Name of the Virtual Network to be used

.PARAMETER VirtualNetworkRGName
    Name of the Resource Group where the Virtual Network resides

.PARAMETER SubnetName
    Name of the subnet to be used for node pool

.PARAMETER AgentCount
    Number of worker node instances

.PARAMETER WorkerNodeVMSize
    workerNodeVMSize is the size of nodes

.PARAMETER OsType
    osType worker node for AKS cluster

.PARAMETER DeploymentDebugLevel
    DeploymentDebugLevel is None

.PARAMETER AgentPoolName
    agent pool name for AKS worker nodes
#>
[CmdletBinding()]
Param (
    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [String] $ClusterName,

    [Parameter(Mandatory = $true)]
    [ValidateSet("westeurope", "northeurope", "westus2", "westus", "westus3", "eastus2", "centralus", "westcentralus", "japaneast", "japanwest")]
    [String] $Location,

    [Parameter(Mandatory = $true)]
    [String] $VirtualNetworkRGName,

    [Parameter(Mandatory = $true)]
    [String] $VirtualNetworkName,

    [Parameter(Mandatory = $true)]
    [String] $SubnetName,

    [Parameter(Mandatory = $true)]
    [Int] $AgentCount,

    [Parameter(Mandatory = $true)]
    [String] $WorkerNodeVMSize,

    [Parameter(Mandatory = $true)]
    [ValidateSet("linux", "windows")]
    [String] $OsType,

    [Parameter(Mandatory = $true)]
    [ValidateSet('None')]
    [String] $DeploymentDebugLevel,

    [Parameter(Mandatory = $true)]
    [String] $AgentPoolName,

    [Parameter(Mandatory = $false)]
    [Int] $MaxPods = 30
)

$TemplateName = 'aksAddAgentpool.json'
Write-Verbose 'Creating parameters object for ARM Template.'
$ParameterARM = @{
    clusterName          = $ClusterName
    location             = $Location
    virtualNetworkRGName = $VirtualNetworkRGName
    virtualNetworkName   = $VirtualNetworkName
    subnetName           = $SubnetName
    agentCount           = $AgentCount
    workerNodeVMSize     = $WorkerNodeVMSize
    osType               = $OsType
    agentPoolName        = $AgentPoolName
    maxPods              = $MaxPods
}
Write-Host 'Get template for AKS node pool add.'
$TemplateFile = Join-Path -Path $PSScriptRoot -ChildPath "..\arm\$TemplateName"
$TemplateName = (Get-ChildItem $TemplateFile).BaseName
$DeploymentName = "ARM-deployment-$( -join ((0x30..0x39) + ( 0x41..0x5A) + ( 0x61..0x7A) | Get-Random -Count 48  | ForEach-Object {[char]$_}) )"

$DeploymentParams = @{
    Name                    = $DeploymentName
    ResourceGroupName       = $ResourceGroupName
    TemplateFile            = $TemplateFile
    TemplateParameterObject = $ParameterARM
    DeploymentDebugLogLevel = $DeploymentDebugLevel
    ErrorVariable           = 'errorMessages'
    ErrorAction             = 'SilentlyContinue'
    Verbose                 = $true
}
Write-Verbose 'Deploying ARM Template.'
New-AzResourceGroupDeployment @DeploymentParams
If ($errorMessages) {
    Write-Error "Template deployment returned the following errors: $errorMessages"
}
----------------------------------------------------
<#
    .SYNOPSIS
        Creates a new Blob Container within a Storage Account

    .DESCRIPTION
        Creates a new Blob Container within the specifiied Azure Storage Account

    .PARAMETER ResourceGroupName
        Name of the Resource Group where the Storage Account is located

    .PARAMETER StorageAccountName
        Name of the Storage Account where the Blob Container should be created

    .PARAMETER ContainerName
        Name of the Container that should be created

    .EXAMPLE
        .\Create-BlobContainer.ps1 -ResourceGroupName demo01-rg -StorageAccountName demo01-sa -ContainerName demo01-container
#>
Param (
    [Parameter(Mandatory = $true)]
    [string] $StorageAccountName,
    [Parameter(Mandatory = $true)]
    [ValidateScript( {
            $ContainerName = $_
            if ($ContainerName -cmatch '^[a-z0-9]{1}[a-z0-9-]{1,61}[a-z0-9]{1}$') {
                Return $True
            }
            else {
                Throw "Container name '$ContainerName' is invalid. Valid names start and end with a lower case letter or a number and has in between a lower case letter, number or dash with no consecutive dashes and is 3 through 63 characters long."
            }
        })]
    [string] $ContainerName
)

[int]$Retry = 12
[int]$SleepInSeconds = 15

Write-Host "Start creation of storage account container '$ContainerName'"

Write-Host 'Specifying storage account context'
$Context = New-AzStorageContext -StorageAccountName $StorageAccountName -UseConnectedAccount
Write-Verbose ($Context | ConvertTo-Json)

Write-Host "Verifying if container '$ContainerName' is already present"
$Container = Get-AzStorageContainer -Context $Context -Name $ContainerName -ErrorAction SilentlyContinue

if ($null -eq $Container) {
    [int]$Count = 1
    do {
        Write-Host "Creating blob storage container '$ContainerName' (Attempt '$Count' of $Retry)"
        $Container = New-AzStorageContainer -Context $Context -Name $ContainerName -ErrorAction SilentlyContinue -ErrorVariable Failed

        if ($Failed) {
            $Failed | Out-Host
        }

        if ($null -ne $Container) {
            break
        }

        $Count++

        if ($Count -le $Retry) {
            Write-Host "Pausing execution for $SleepInSeconds seconds"
            Start-Sleep -Seconds $SleepInSeconds
            $SleepInSeconds += 15

            Write-Host "Refreshing storage context"
            Remove-Variable -Name Context
            $Context = New-AzStorageContext -StorageAccountName $StorageAccountName -UseConnectedAccount
        }
    } while ($Count -le $Retry)

    if ($Count -gt $Retry -or $null -eq $Container) {
        Write-Error "Failed to create blob storage container '$ContainerName'"
        #throw $Failed
    }
}

Write-Host "Storage account container present"

@{
    ContainerName     = $Container.Name
    ContainerEndPoint = $Container.CloudBlobContainer.Uri
}

Write-Host "Storage account container creation completed"
---------------------------------------------------------------------------
Param (
    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [String] $StorageAccountName,

    [Parameter(Mandatory = $true)]
    [String] $ContainerName,

    [Parameter(Mandatory = $true)]
    [String] $FileName,

    [Parameter(Mandatory = $false)]
    [String] $DirectoryName,

    [Parameter(Mandatory = $false)]
    [string]
    [ValidateLength(1, 7)]
    [ValidatePattern("^[a-zA-Z]+$")]
    $Permissions
)

# Setting default values
if ([string]::IsNullOrEmpty($Permissions)) {
    $Permissions = 'r'
    Write-Output "Permissions set to default value '$Permissions'."
}
else {
    Write-Output "Permissions '$Permissions' used from parameter"
}

if ([string]::IsNullOrEmpty($DirectoryName)) {
    $Blob = $FileName
}
else {
    $Blob = '{0}\{1}' -f $DirectoryName, $Filename
}
Write-Output ('SasToken generated for file {0}.' -f $Blob)

try {

    $Key0 = Get-AzStorageAccountKey -ResourceGroupName $ResourceGroupName -Name $StorageAccountName | Select-Object -First 1 -ExpandProperty Value
    $Context = New-AzStorageContext -StorageAccountName $StorageAccountName -StorageAccountKey $Key0

    # To generate sastokens accountkey is needed. Below option is not possible in this situation
    # $Context = New-AzStorageContext -StorageAccountName $StorageAccountName -UseConnectedAccount

    $Params = @{
        'Container'  = $ContainerName
        'Blob'       = $Blob
        'Permission' = $Permissions
        'Context'    = $Context
        'ExpiryTime' = (Get-Date).AddDays(1).ToUniversalTime()
    }
    $SASToken = New-AzStorageBlobSASToken @Params
    Write-output ('New SasToken is generated valid for 24h.')

    # Convert SasToken to securestring
    # $SecureSaSToken = ConvertTo-SecureString -String ($SASToken) -AsPlainText -Force
    Write-Output -InputObject ('##vso[task.setvariable variable=SASToken;issecret=true;]{0}' -f $SaSToken)
    return $SasToken
}
catch {
    Write-Error $_
}
--------------------------------------------------
<#
.SYNOPSIS
Creates an Azure Storage Account.

.DESCRIPTION
Creates a Storage Account with the specified name and settings.

.OUTPUTS
HashTable
Information on the Created Resource"

.EXAMPLE
Create-StorageAccount.ps1 -ResourceGroupName ccoe-dta01-rg -StorageAccountName ccoedta01tstsa -StorageAccountSku Standard_LRS -StorageAccountKind BlobStorage -AccessTier Hot -IpRules '84.24.135.30'

This command will create storage account ccoedta01tstsa in the same Azure region as the resource group.
Public IP address 84.24.135.30 is configured in the firewall to allow access.
#>
[CmdletBinding()]
Param (
    [Parameter(
        Mandatory = $true,
        HelpMessage = "Name of the Resource Group where the Storage Account will be created")]
    [String]$ResourceGroupName,

    [Parameter(
        Mandatory = $true,
        HelpMessage = "Storage Account Name that will be created in the Resource Group name")]
    [ValidateLength(3, 24)]
    [ValidatePattern("^[a-z0-9]+$")]
    [String]$StorageAccountName,

    [Parameter(
        Mandatory = $true,
        HelpMessage = "Sku for the Storage Account being created")]
    [ValidateSet('Standard_LRS', 'Standard_GRS', 'Standard_RAGRS', 'Standard_ZRS', 'Standard_GZRS', 'Standard_RAZRS', 'Premium_LRS')]
    [String]$StorageAccountSku,

    [Parameter(
        Mandatory = $true,
        HelpMessage = "Kind of Storage Account being created (Blob Storage, Storage Account v2 or Data Lake Store)")]
    [ValidateSet('BlobStorage', 'BlockBlobStorage', 'FileStorage', 'StorageV2', 'DataLakeStoreGen2')]
    [String]$StorageAccountKind,

    [Parameter(
        Mandatory = $false,
        HelpMessage = "Access tier for the Storage Account being created")]
    [ValidateSet('Hot', 'Cool')]
    [String]$AccessTier,

    [Parameter(
        Mandatory = $false,
        HelpMessage = "Public IP addresses and/or IP address ranges which should be granted explicit permission to the storage account.")]
    [Array]$IpRules,

    [Parameter(
        Mandatory = $false,
        HelpMessage = "To Enable Nfsv3 protocol for storage account.")]
    [Boolean]$isNfsV3Enabled,

    [Parameter(
        Mandatory = $false,
        HelpMessage = "Provide the Azure location in where the storage account is to be provisioned")]
    [String]$Location,

    [Parameter(Mandatory = $false)]
    [Switch]$DoNotSendMetrics,

    [Parameter(
        Mandatory = $false,
        HelpMessage = "To enable/disable usage of shared access key. Default is disabled")]
    [Boolean]$SharedAccessKeyEnabled = $false

)
Function Test-IpRules {
    <#
    .DESCRIPTION
    Validate the informed IP rules, if any, and return a concatenated string with all the values.
    #>
    [CmdLetBinding()]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseSingularNouns", "")]
    Param(
        [Parameter(Mandatory = $false)]
        [Array] $IpRules
    )
    $PrivateIpAddressPattern = '(^127\.)|(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])'
    $IPAddressPattern = '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0]))$'
    if (-Not [string]::IsNullOrWhiteSpace($IpRules)) {
        foreach ($IpRangeOrAddress In $IpRules) {
            if ($IpRangeOrAddress -match $PrivateIpAddressPattern) {
                throw "Only public IP addresses are allowed"
            }
            elseif ($IpRangeOrAddress -notmatch $IPAddressPattern) {
                throw "'$IpRangeOrAddress' is not a valid IPv4 address or CIDR range (CIDR must be smaller than or equal to 30)."
            }
        }
    }

    $IpRulesString = $IpRules -Join ","

    $IpRulesString
}

$IpRulesString = Test-IpRules -IpRules $IpRules

Write-Verbose "Get template for storage account"
if ($StorageAccountKind -eq 'DataLakeStoreGen2') {
    $StorageAccountKind = 'StorageV2'

    if ($StorageAccountSku -match "Premium") {
        throw "Data Lake Storage Gen2 does not support the premium storage sku."
    }

    $TemplateFile = Join-Path -Path $PSScriptRoot -ChildPath "..\arm\dls2.json"
    [hashtable]$ParametersARM = @{
        storageAccountName = $StorageAccountName
        storageAccountSku  = $StorageAccountSku
        storageAccountKind = $StorageAccountKind
        ipRange            = $IpRulesString
        isNfsV3Enabled     = $isNfsV3Enabled
    }
}
else {

    if ($StorageAccountKind -eq 'BlockBlobStorage' -or $StorageAccountKind -eq 'FileStorage') {
        if ($StorageAccountSku -ne 'Premium_LRS') {
            throw "Storage account kind '$($StorageAccountKind)' is only available on Premium Locally-redundant storage (Premium_LRS). `n You selected: '$($StorageAccountSku)'"
        }
    }
    if ($isNfsV3Enabled -eq 'true') {
        if ($StorageAccountKind -ne 'DataLakeStoreGen2') {
            throw "Storage account NfsV3 protocol feature only available with StorageAccountKind (DataLakeStoreGen2)."
        }
    }

    $TemplateFile = Join-Path -Path $PSScriptRoot -ChildPath "..\arm\storageAccount.json"
    [hashtable]$ParametersARM = @{
        storageAccountName = $StorageAccountName
        storageAccountSku  = $StorageAccountSku
        storageAccountKind = $StorageAccountKind
        ipRange            = $IpRulesString
    }
}

#Below is to make sure InfraEncryption is enabled on new Storage Account(SA)
$SA = Get-AzStorageAccount -ResourceGroupName $ResourceGroupName -StorageAccountName $StorageAccountName -ErrorAction 'SilentlyContinue'
if (-Not $SA) {
    $ParametersARM.Add('newOrExisting', "new")
}
else {
    $ParametersARM.Add('newOrExisting', "existing")
}

if (-Not ([string]::IsNullOrWhiteSpace($Location))) {
    $ParametersARM.Add('location', $Location)
}

if (-Not ([string]::IsNullOrWhiteSpace($AccessTier))) {
    $ParametersARM.Add('accessTier', $AccessTier)
}

#Limiting Deployment name to 64 characters
$DeploymentName = "ARM-deployment-$( -join ((0x30..0x39) + ( 0x41..0x5A) + ( 0x61..0x7A) | Get-Random -Count 48  | ForEach-Object {[char]$_}) )"

Write-Host "Deploy storage account ARM template"
Write-Verbose $TemplateFile
try {
    [hashtable]$DeploymentParameters = @{
        Name                    = $DeploymentName
        ResourceGroupName       = $ResourceGroupName
        TemplateFile            = $TemplateFile
        TemplateParameterObject = $ParametersARM
    }
    Write-Verbose ($DeploymentParameters | ConvertTo-Json -Depth 4)
    $Result = New-AzResourceGroupDeployment @DeploymentParameters
}
catch {
    $ErrorMessage = $_.Exception.Message
    Write-Verbose ($ErrorMessage | ConvertTo-Json -Depth 10)
    if ($ErrorMessage.Contains('isHnsEnabled') -and $ErrorMessage.Contains('AccountPropertyCannotBeUpdated')) {

        Write-Error $_.Exception -ErrorAction Continue
        throw 'Data Lake Store Gen2 features can only be enabled/disabled during the creation of a Storage Account.'
    }

    # When the ARM template is not valid, the details are logged in the Azure Activity Logs, but not returned by New-AzResourceGroupDeployment
    # Execute a Test-AzResourceGroupDeployment to try to get the actual error message.
    if ($_.Exception.Message.Contains('Code=InvalidTemplateDeployment')) {
        Write-Host 'Code=InvalidTemplateDeployment'
        $DeploymentParameters.Remove('Name')
        $DetailsList = (Test-AzResourceGroupDeployment @DeploymentParameters)
        $DetailsItem = $DetailsList[0]
        $lastErrorMessage = $_.Exception.Message
        while ($DetailsItem) {
            $errorMessage = "$($DetailsItem.Code): $($DetailsItem.Message)"
            Write-Warning $errorMessage -ErrorAction Continue
            $lastErrorMessage = $errorMessage
            # It's a chained list of detail objects.
            $DetailsItem = $DetailsItem.Details
        }
        throw $lastErrorMessage
    }

    throw $_
}

if ($SharedAccessKeyEnabled -eq $true) {
    Write-Host "Enabling shared access key for storage account with SasExpirationPeriod 7 days."
    Set-AzStorageAccount -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName -AllowSharedKeyAccess $SharedAccessKeyEnabled -SasExpirationPeriod 7.00:00:00
}
else {
    Set-AzStorageAccount -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName -AllowSharedKeyAccess $SharedAccessKeyEnabled
}

$output = [HashTable] @{
    ResourceID   = $Result.Outputs['resourceID'].Value
    ResourceName = $Result.Outputs['resourceName'].Value
}

if ($OutputVariableName) {
    Write-Host "Writing output variable:"
    $output.Keys | ForEach-Object {
        Write-Host "- $OutputVariableName.$($_) = $($output[$_])"
        Write-Host "##vso[task.setVariable variable=$OutputVariableName.$($_)]$($output[$_])"
        Write-Host "##vso[task.setVariable variable=$OutputVariableName.$($_);isOutput=true]$($output[$_])"
    }
}

Write-Output $output
--------------------------------------------
<#
    .SYNOPSIS
        Add Role assignements to the created storage account

    .DESCRIPTION
        This function will add any role assignment selected by the user to the storage account that is being created by the extension

    .PARAMETER ResourceGroupName
        Name of the resource group that contains the Storage Account

    .PARAMETER StorageAccountName
        Name of Storage Account that was created

    .PARAMETER ServicePrincipalId
        Id of the user Service Principal (This is the user running the extension context)

    .PARAMETER Roles
        Comma-seperated list of roles to be added to the Service Principal for this Storage Account

    .EXAMPLE
        Add-RoleAssignments -ResourceGroupName ResourceGroupA -StorageAccountName appstorage -ServicePrincipalId user@asml.com -Roles "Storage Blob Data Contributor,Storage Blob Data Owner"
#>
[CmdLetBinding()]
Param(
    [Parameter(Mandatory = $true)]
    [String] $ResourceGroupName,
    [Parameter(Mandatory = $true)]
    [String] $StorageAccountName,
    [Parameter(Mandatory = $true)]
    [String] $Roles,
    [Parameter(Mandatory = $false)]
    [String] $ServicePrincipalId
)

# Retrieve the ServicePrincipalId from the current context
if ([string]::IsNullOrWhiteSpace($ServicePrincipalId)) {
    $ContextAccountId = (Get-AzContext).Account.Id
    $ServicePrincipal = Get-AzADServicePrincipal -ServicePrincipalName $ContextAccountId
    $ServicePrincipalId = $ServicePrincipal.Id
}

Function Wait-StorageAccountProvisioning {
    <#
        .SYNOPSIS
            Wait for the provisioning of the Storage Account
        .DESCRIPTION
            Waits for the provisioning of the Storage Account. Max waiting time is 2 minutes.
        .PARAMETER StorageAccountName
            Name of the storage account being provisioned
        .EXAMPLE
            Wait-StorageAccountProvisioning -StorageAccountName mystorageaccount
    #>
    [CmdLetBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [String]$StorageAccountName
    )
    $StorageAccount = (Get-AzStorageAccount | Where-Object { $_.StorageAccountName -eq $StorageAccountName })
    $SleepInSeconds = 2

    While ($null -ne $StorageAccount) {
        Write-Verbose "Waiting for $SleepInSeconds seconds to get the Storage Account '$StorageAccountName'..."
        Start-Sleep -Seconds $SleepInSeconds

        $StorageAccount = (Get-AzStorageAccount | Where-Object { $_.StorageAccountName -eq $StorageAccountName })

        $SleepInSeconds = $SleepInSeconds * 2
        if ($SleepInSeconds -gt 32) {
            break
        }
    }
}

Wait-StorageAccountProvisioning -StorageAccountName $StorageAccountName

$AvailableRoleAssignments = @(
    "Storage Account Contributor",
    "Storage Account Key Operator Service Role",
    "Storage Blob Data Contributor",
    "Storage Blob Data Owner",
    "Storage Blob Data Reader",
    "Storage Queue Data Contributor",
    "Storage Queue Data Message Processor",
    "Storage Queue Data Message Sender",
    "Storage Queue Data Reader"
)

# Set Role Assignment if selected in task
Foreach ($Role in $AvailableRoleAssignments) {
    $RoleName = $Role.Replace(' ', '')

    $RoleSelected = $Roles.Replace(' ', '').Contains($RoleName)
    If ($RoleSelected) {
        # Apply Role Assignment
        Write-Verbose -Message "Applying Role Assignment '$Role'"

        $Scope = (Get-AzResource -Name $StorageAccountName -ResourceGroupName $ResourceGroupName).ResourceId
        $RoleAssignments = Get-AzRoleAssignment -ObjectId $ServicePrincipalId -Scope $Scope
        If (($RoleAssignments).RoleDefinitionName -notcontains $Role) {
            # Set role on service principal
            $RoleAssignmentParams = @{
                RoleDefinitionName = $Role
                Scope              = $Scope
                ObjectId           = $ServicePrincipalId
            }

            Write-Verbose ($RoleAssignmentParams | ConvertTo-Json)
            New-AzRoleAssignment @RoleAssignmentParams -ErrorAction Stop

            Write-Output "Role '$Role' applied for '$ServicePrincipalId' on Storage Account '$StorageAccountName'"
        }
        Else {
            Write-Output "Role '$Role' already applied to '$ServicePrincipalId' on Storage Account '$StorageAccountName'"
        }
    }
}
----------------------------------------------------------------------

Param (
    [Parameter(Mandatory = $true)]
    [string] $ResourceGroupName,

    [Parameter(Mandatory = $true)]
    [string] $StorageAccountName,

    # Should be a comma delimited string such as: "8.8.8.8,28.1.0.0/16"
    [Parameter(Mandatory = $false)]
    [string] $IPAddressOrRange
)

# Constants
$Url = "http://ifconfig.me/ip"

if ([string]::IsNullOrEmpty($IPAddressOrRange)) {
    Write-Host "Obtaining public IP address of the agent"
    $IPAddressOrRangeArray = (Invoke-WebRequest -Uri $Url -ErrorAction SilentlyContinue).Content
    Write-Host "Found IP address: '$IPAddressOrRangeArray'"
}
else {
    # Check if IPAddressOrRange is a valid IP address or CIDR range
    $IPAddressOrRangeArray = ($IPAddressOrRange.split(",")).replace(' ', '')
    if (!([string]::IsNullOrEmpty($IPAddressOrRange.Trim()))) {
        foreach ($IPAddressOrRange In $IPAddressOrRangeArray) {
            Write-Host "Validating IP address '$IPAddressOrRange'"
            [bool] $IsValidIP = $IPAddressOrRange -Match '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))?$'

            if (!$IsValidIP) {
                Write-Error "The specified IP address is not a valid IPv4 address or CIDR range."
                $HasError = $true
            }
        }
    }
}

if ($HasError) {
    return
}

# Get the current IP rules:
Write-Host "Retrieving existing storage account IP address rules"
$CurrentRuleSet = (Get-AzStorageAccountNetworkRuleSet -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName).IPRules.IPAddressOrRange

foreach ($IPAddressOrRangeItem in $IPAddressOrRangeArray) {
    Write-Host "Handling IP address (range): '$IPAddressOrRangeItem'"
    If ($CurrentRuleSet -notcontains $IPAddressOrRangeItem) {
        [int]$Count = 0
        do {
            Write-Host "Adding IP address (range) to storage account IP address allow list"
            Add-AzStorageAccountNetworkRule -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName -IPAddressOrRange $IPAddressOrRangeItem

            Write-Host "Validating if IP address (range) is added successfully"
            $CheckNetworkRule = (Get-AzStorageAccountNetworkRuleSet -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName).IPRules.IPAddressOrRange
            Write-Host "$($CheckNetworkRule | Out-String)"
            $Failed = $false
            if ($CheckNetworkRule -notcontains $IPAddressOrRangeItem) {
                $Failed = $true
                $Count++
                Write-Host "Failed to add IP address (range) to the firewall rules - pausing for 10 seconds before next attempt"
                Start-Sleep -Seconds 10
            }
            else {
                Write-Host 'IP address (range) successfully added to the allow list'
            }
        } while ($Failed -or $Count -gt 12)
    }
    else {
        Write-Host 'IP address (range) already present to the allow list'
    }
}

---------------------------------------------------

